Id,Title,ParentId,OwnerUserId,Score,Body
29481088,How can I tell if a string repeats itself in Python?,,467090.0,320,"<p>I'm looking for a way to test whether or not a given string repeats itself for the entire string or not.</p>

<p>Examples:</p>

<pre><code>[
    '0045662100456621004566210045662100456621',             # '00456621'
    '0072992700729927007299270072992700729927',             # '00729927'
    '001443001443001443001443001443001443001443',           # '001443'
    '037037037037037037037037037037037037037037037',        # '037'
    '047619047619047619047619047619047619047619',           # '047619'
    '002457002457002457002457002457002457002457',           # '002457'
    '001221001221001221001221001221001221001221',           # '001221'
    '001230012300123001230012300123001230012300123',        # '00123'
    '0013947001394700139470013947001394700139470013947',    # '0013947'
    '001001001001001001001001001001001001001001001001001',  # '001'
    '001406469760900140646976090014064697609',              # '0014064697609'
]
</code></pre>

<p>are strings which repeat themselves, and</p>

<pre><code>[
    '004608294930875576036866359447',
    '00469483568075117370892018779342723',
    '004739336492890995260663507109',
    '001508295625942684766214177978883861236802413273',
    '007518796992481203',
    '0071942446043165467625899280575539568345323741',
    '0434782608695652173913',
    '0344827586206896551724137931',
    '002481389578163771712158808933',
    '002932551319648093841642228739',
    '0035587188612099644128113879',
    '003484320557491289198606271777',
    '00115074798619102416570771',
]
</code></pre>

<p>are examples of ones that do not.</p>

<p>The repeating sections of the strings I'm given can be quite long, and the strings themselves can be 500 or more characters, so looping through each character trying to build a pattern then checking the pattern vs the rest of the string seems awful slow. Multiply that by potentially hundreds of strings and I can't see any intuitive solution.</p>

<p>I've looked into regexes a bit and they seem good for when you know what you're looking for, or at least the length of the pattern you're looking for. Unfortunately, I know neither.</p>

<p>How can I tell if a string is repeating itself and if it is, what the shortest repeating subsequence is?</p>
"
29481228,,29481088.0,1014938.0,173,"<p>Here's a solution using regular expressions.</p>

<pre><code>import re

REPEATER = re.compile(r""(.+?)\1+$"")

def repeated(s):
    match = REPEATER.match(s)
    return match.group(1) if match else None
</code></pre>

<p>Iterating over the examples in the question:</p>

<pre><code>examples = [
    '0045662100456621004566210045662100456621',
    '0072992700729927007299270072992700729927',
    '001443001443001443001443001443001443001443',
    '037037037037037037037037037037037037037037037',
    '047619047619047619047619047619047619047619',
    '002457002457002457002457002457002457002457',
    '001221001221001221001221001221001221001221',
    '001230012300123001230012300123001230012300123',
    '0013947001394700139470013947001394700139470013947',
    '001001001001001001001001001001001001001001001001001',
    '001406469760900140646976090014064697609',
    '004608294930875576036866359447',
    '00469483568075117370892018779342723',
    '004739336492890995260663507109',
    '001508295625942684766214177978883861236802413273',
    '007518796992481203',
    '0071942446043165467625899280575539568345323741',
    '0434782608695652173913',
    '0344827586206896551724137931',
    '002481389578163771712158808933',
    '002932551319648093841642228739',
    '0035587188612099644128113879',
    '003484320557491289198606271777',
    '00115074798619102416570771',
]

for e in examples:
    sub = repeated(e)
    if sub:
        print(""%r: %r"" % (e, sub))
    else:
        print(""%r does not repeat."" % e)
</code></pre>

<p>... produces this output:</p>

<pre><code>'0045662100456621004566210045662100456621': '00456621'
'0072992700729927007299270072992700729927': '00729927'
'001443001443001443001443001443001443001443': '001443'
'037037037037037037037037037037037037037037037': '037'
'047619047619047619047619047619047619047619': '047619'
'002457002457002457002457002457002457002457': '002457'
'001221001221001221001221001221001221001221': '001221'
'001230012300123001230012300123001230012300123': '00123'
'0013947001394700139470013947001394700139470013947': '0013947'
'001001001001001001001001001001001001001001001001001': '001'
'001406469760900140646976090014064697609': '0014064697609'
'004608294930875576036866359447' does not repeat.
'00469483568075117370892018779342723' does not repeat.
'004739336492890995260663507109' does not repeat.
'001508295625942684766214177978883861236802413273' does not repeat.
'007518796992481203' does not repeat.
'0071942446043165467625899280575539568345323741' does not repeat.
'0434782608695652173913' does not repeat.
'0344827586206896551724137931' does not repeat.
'002481389578163771712158808933' does not repeat.
'002932551319648093841642228739' does not repeat.
'0035587188612099644128113879' does not repeat.
'003484320557491289198606271777' does not repeat.
'00115074798619102416570771' does not repeat.
</code></pre>

<p>The regular expression <code>(.+?)\1+$</code> is divided into three parts:</p>

<ol>
<li><p><code>(.+?)</code> is a matching group containing at least one (but as few as possible) of any character (because <a href=""https://docs.python.org/3/library/re.html#regular-expression-syntax""><code>+?</code> is non-greedy</a>).</p></li>
<li><p><code>\1+</code> checks for at least one repetition of the matching group in the first part.</p></li>
<li><p><code>$</code> checks for the end of the string, to ensure that there's no extra, non-repeating content after the repeated substrings (and using <a href=""https://docs.python.org/3/library/re.html#re.match""><code>re.match()</code></a> ensures that there's no non-repeating text <em>before</em> the repeated substrings).</p></li>
</ol>

<p>In Python 3.4 and later, you could drop the <code>$</code> and use <a href=""https://docs.python.org/3/library/re.html#re.fullmatch""><code>re.fullmatch()</code></a> instead, or (in any Python at least as far back as 2.3) go the other way and use <a href=""https://docs.python.org/3/library/re.html#re.search""><code>re.search()</code></a> with the regex <code>^(.+?)\1+$</code>, all of which are more down to personal taste than anything else.</p>
"
29481244,,29481088.0,2617068.0,37,"<p>Non-regex solution:</p>

<pre><code>def repeat(string):
    for i in range(1, len(string)//2+1):
        if not len(string)%len(string[0:i]) and string[0:i]*(len(string)//len(string[0:i])) == string:
            return string[0:i]
</code></pre>

<p>Faster non-regex solution, thanks to @ThatWeirdo (see comments):</p>

<pre><code>def repeat(string):
    l = len(string)
    for i in range(1, len(string)//2+1):
        if l%i: continue
        s = string[0:i]
        if s*(l//i) == string:
            return s
</code></pre>

<p>The above solution is very rarely slower than the original by a few percent, but it's usually a good bit faster - sometimes a whole lot faster. It's still not faster than davidism's for longer strings, and zero's regex solution is superior for short strings. It comes out to the fastest (according to davidism's test on github - see his answer) with strings of about 1000-1500 characters. Regardless, it's reliably second-fastest (or better) in all cases I tested. Thanks, ThatWeirdo.</p>

<p>Test:</p>

<pre><code>print(repeat('009009009'))
print(repeat('254725472547'))
print(repeat('abcdeabcdeabcdeabcde'))
print(repeat('abcdefg'))
print(repeat('09099099909999'))
print(repeat('02589675192'))
</code></pre>

<p>Results:</p>

<pre><code>009
2547
abcde
None
None
None
</code></pre>
"
29481262,,29481088.0,2653390.0,89,"<p>You can make the observation that for a string to be considered repeating, its length must be divisible by the length of its repeated sequence. Given that, here is a solution that generates divisors of the length from <code>1</code> to <code>n / 2</code> inclusive, divides the original string into substrings with the length of the divisors, and tests the equality of the result set:</p>

<pre><code>from math import sqrt, floor

def divquot(n):
    if n &gt; 1:
        yield 1, n
    swapped = []
    for d in range(2, int(floor(sqrt(n))) + 1):
        q, r = divmod(n, d)
        if r == 0:
            yield d, q
            swapped.append((q, d))
    while swapped:
        yield swapped.pop()

def repeats(s):
    n = len(s)
    for d, q in divquot(n):
        sl = s[0:d]
        if sl * q == s:
            return sl
    return None
</code></pre>

<p><strong>EDIT:</strong> In Python 3, the <code>/</code> operator has changed to do float division by default. To get the <code>int</code> division from Python 2, you can use the <code>//</code> operator instead. Thank you to @TigerhawkT3 for bringing this to my attention.</p>

<p>The <code>//</code> operator performs integer division in both Python 2 and Python 3, so I've updated the answer to support both versions. The part where we test to see if all the substrings are equal is now a short-circuiting operation using <code>all</code> and a generator expression.</p>

<p><strong>UPDATE:</strong> In response to a change in the original question, the code has now been updated to return the smallest repeating substring if it exists and <code>None</code> if it does not. @godlygeek has suggested using <code>divmod</code> to reduce the number of iterations on the <code>divisors</code> generator, and the code has been updated to match that as well. It now returns all positive divisors of <code>n</code> in ascending order, exclusive of <code>n</code> itself.</p>

<p><strong>Further update for high performance:</strong> After multiple tests, I've come to the conclusion that  simply testing for string equality has the best performance out of any slicing or iterator solution in Python. Thus, I've taken a leaf out of @TigerhawkT3 's book and updated my solution. It's now over 6x as fast as before, noticably faster than Tigerhawk's solution but slower than David's.</p>
"
29482465,,29481088.0,4596008.0,16,"<p>Here's a straight forward solution, without regexes. </p>

<p>For substrings of <code>s</code> starting from zeroth index, of lengths 1 through <code>len(s)</code>, check if that substring, <code>substr</code> is the repeated pattern. This check can be performed by concatenating <code>substr</code> with itself <code>ratio</code> times, such that the length of the string thus formed is equal to the length of <code>s</code>. Hence <code>ratio=len(s)/len(substr)</code>. </p>

<p>Return when first such substring is found. This would provide the smallest possible substring, if one exists.</p>

<pre><code>def check_repeat(s):
    for i in range(1, len(s)):
        substr = s[:i]
        ratio = len(s)/len(substr)
        if substr * ratio == s:
            print 'Repeating on ""%s""' % substr
            return
    print 'Non repeating'

&gt;&gt;&gt; check_repeat('254725472547')
Repeating on ""2547""
&gt;&gt;&gt; check_repeat('abcdeabcdeabcdeabcde')
Repeating on ""abcde""
</code></pre>
"
29482830,,29481088.0,400617.0,23,"<p>First, halve the string as long as it's a ""2 part"" duplicate.  This reduces the search space if there are an even number of repeats.  Then, working forwards to find the smallest repeating string, check if splitting the full string by increasingly larger sub-string results in only empty values.  Only sub-strings up to <code>length // 2</code> need to be tested since anything over that would have no repeats.</p>

<pre><code>def shortest_repeat(orig_value):
    if not orig_value:
        return None

    value = orig_value

    while True:
        len_half = len(value) // 2
        first_half = value[:len_half]

        if first_half != value[len_half:]:
            break

        value = first_half

    len_value = len(value)
    split = value.split

    for i in (i for i in range(1, len_value // 2) if len_value % i == 0):
        if not any(split(value[:i])):
            return value[:i]

    return value if value != orig_value else None
</code></pre>

<p>This returns the shortest match or None if there is no match.</p>
"
29482936,,29481088.0,400617.0,81,"<p>Here are some benchmarks for the various answers to this question. There were some surprising results, including wildly different performance depending on the string being tested.</p>

<p>Some functions were modified to work with Python 3 (mainly by replacing <code>/</code> with <code>//</code> to ensure integer division). If you see something wrong, want to add your function, or want to add another test string, ping @ZeroPiraeus in the <a href=""http://chat.stackoverflow.com/rooms/6/python"">Python chatroom</a>.</p>

<p>In summary: there's about a 50x difference between the best- and worst-performing solutions for the large set of example data supplied by OP <a href=""http://paste.ubuntu.com/10765231/"">here</a> (via <a href=""http://stackoverflow.com/questions/29481088/how-can-i-tell-if-a-string-repeats-itself-in-python#comment47156601_29481088"">this</a> comment). <a href=""http://stackoverflow.com/a/29489919"">David Zhang's solution</a> is the clear winner, outperforming all others by around 5x for the large example set.</p>

<p>A couple of the answers are <em>very</em> slow in extremely large ""no match"" cases. Otherwise, the functions seem to be equally matched or clear winners depending on the test.</p>

<p>Here are the results, including plots made using matplotlib and seaborn to show the different distributions:</p>

<hr>

<p><strong>Corpus 1 (supplied examples - small set)</strong></p>

<pre><code>mean performance:
 0.0003  david_zhang
 0.0009  zero
 0.0013  antti
 0.0013  tigerhawk_2
 0.0015  carpetpython
 0.0029  tigerhawk_1
 0.0031  davidism
 0.0035  saksham
 0.0046  shashank
 0.0052  riad
 0.0056  piotr

median performance:
 0.0003  david_zhang
 0.0008  zero
 0.0013  antti
 0.0013  tigerhawk_2
 0.0014  carpetpython
 0.0027  tigerhawk_1
 0.0031  davidism
 0.0038  saksham
 0.0044  shashank
 0.0054  riad
 0.0058  piotr
</code></pre>

<p><a href=""http://i.stack.imgur.com/Xx34F.png""><img src=""http://i.stack.imgur.com/Xx34F.png"" alt=""Corpus 1 graph""></a></p>

<hr>

<p><strong>Corpus 2 (supplied examples - large set)</strong></p>

<pre><code>mean performance:
 0.0006  david_zhang
 0.0036  tigerhawk_2
 0.0036  antti
 0.0037  zero
 0.0039  carpetpython
 0.0052  shashank
 0.0056  piotr
 0.0066  davidism
 0.0120  tigerhawk_1
 0.0177  riad
 0.0283  saksham

median performance:
 0.0004  david_zhang
 0.0018  zero
 0.0022  tigerhawk_2
 0.0022  antti
 0.0024  carpetpython
 0.0043  davidism
 0.0049  shashank
 0.0055  piotr
 0.0061  tigerhawk_1
 0.0077  riad
 0.0109  saksham
</code></pre>

<p><a href=""http://i.stack.imgur.com/KZgxr.png""><img src=""http://i.stack.imgur.com/KZgxr.png"" alt=""Corpus 1 graph""></a></p>

<hr>

<p><strong>Corpus 3 (edge cases)</strong></p>

<pre><code>mean performance:
 0.0123  shashank
 0.0375  david_zhang
 0.0376  piotr
 0.0394  carpetpython
 0.0479  antti
 0.0488  tigerhawk_2
 0.2269  tigerhawk_1
 0.2336  davidism
 0.7239  saksham
 3.6265  zero
 6.0111  riad

median performance:
 0.0107  tigerhawk_2
 0.0108  antti
 0.0109  carpetpython
 0.0135  david_zhang
 0.0137  tigerhawk_1
 0.0150  shashank
 0.0229  saksham
 0.0255  piotr
 0.0721  davidism
 0.1080  zero
 1.8539  riad
</code></pre>

<p><a href=""http://i.stack.imgur.com/w0qqT.png""><img src=""http://i.stack.imgur.com/w0qqT.png"" alt=""Corpus 3 graph""></a></p>

<hr>

<p>The tests and raw results are available <a href=""https://bitbucket.org/snippets/schesis/nMnR/benchmarking-answers-to-http"">here</a>.</p>
"
29484962,,29481088.0,918959.0,16,"<p>This version tries only those candidate sequence lengths that are factors of the string length; and uses the <code>*</code> operator to build a full-length string from the candidate sequence:</p>

<pre><code>def get_shortest_repeat(string):
    length = len(string)
    for i in range(1, length // 2 + 1):
        if length % i:  # skip non-factors early
            continue

        candidate = string[:i]
        if string == candidate * (length // i):
            return candidate

    return None
</code></pre>

<p>Thanks to TigerhawkT3 for noticing that <code>length // 2</code> without <code>+ 1</code> would fail to match the <code>abab</code> case.</p>
"
29489919,,29481088.0,2447250.0,536,"<p>Here's a concise solution which avoids regular expressions and slow in-Python loops:</p>

<pre><code>def principal_period(s):
    i = (s+s).find(s, 1, -1)
    return None if i == -1 else s[:i]
</code></pre>

<p>See the <a href=""http://stackoverflow.com/a/29482936/2447250"">Community Wiki answer</a> started by @davidism for benchmark results. In summary,</p>

<blockquote>
  <p>David Zhang's solution is the clear winner, outperforming all others by at least 5x for the large example set.</p>
</blockquote>

<p>(That answer's words, not mine.)</p>

<p>This is based on the observation that a string is periodic if and only if it is equal to a nontrivial rotation of itself. Kudos to @AleksiTorhamo for realizing that we can then recover the principal period from the index of the first occurrence of <code>s</code> in <code>(s+s)[1:-1]</code>, and for informing me of the optional <code>start</code> and <code>end</code> arguments of Python's <code>string.find</code>.</p>
"
29519746,,29481088.0,768110.0,16,"<p>The problem may also be solved in <code>O(n)</code> in worst case with prefix function.</p>

<p>Note, it may be slower in general case(UPD: and is much slower) than other solutions which depend on number of divisors of <code>n</code>, but usually find fails sooner, I think one of bad cases for them will be <code>aaa....aab</code>, where there are <code>n - 1 = 2 * 3 * 5 * 7 ... *p_n - 1</code> <code>a</code>'s</p>

<p>First of all you need to calculate prefix function</p>

<pre><code>def prefix_function(s):
    n = len(s)
    pi = [0] * n
    for i in xrange(1, n):
        j = pi[i - 1]
        while(j &gt; 0 and s[i] != s[j]):
            j = pi[j - 1]
        if (s[i] == s[j]):
            j += 1
        pi[i] = j;
    return pi
</code></pre>

<p>then either there's no answer or the shortest period is</p>

<pre><code>k = len(s) - prefix_function(s[-1])
</code></pre>

<p>and you just have to check if <code>k != n and n % k == 0</code> (if <code>k != n and n % k == 0</code> then answer is <code>s[:k]</code>, else there's no answer</p>

<p>You may check the proof <a href=""http://e-maxx.ru/algo/prefix_function#header_12"">here</a> (in Russian, but online translator will probably do the trick)</p>

<pre><code>def riad(s):
    n = len(s)
    pi = [0] * n
    for i in xrange(1, n):
        j = pi[i - 1]
        while(j &gt; 0 and s[i] != s[j]):
            j = pi[j - 1]
        if (s[i] == s[j]):
            j += 1
        pi[i] = j;
    k = n - pi[-1]
    return s[:k] if (n != k and n % k == 0) else None
</code></pre>
"
29543743,,29481088.0,3259619.0,9,"<p>I started with more than eight solutions to this problem. Some were bases on regex (match, findall, split), some of string slicing and testing, and some with string methods (find, count, split). Each had benefits in code clarity, code size, speed and memory consumption. I was going to post my answer here when I noticed that execution speed was ranked as important, so I did more testing and improvement to arrive at this:</p>



<pre class=""lang-python prettyprint-override""><code>def repeating(s):
    size = len(s)
    incr = size % 2 + 1
    for n in xrange(1, size//2+1, incr):
        if size % n == 0:
            if s[:n] * (size//n) == s:
                return s[:n]
</code></pre>

<p>This answer seems similar to a few other answers here, but it has a few speed optimisations others have not used:</p>

<ul>
<li><code>xrange</code> is a little faster in this application,</li>
<li>if an input string is an odd length, do not check any even length substrings,</li>
<li>by using <code>s[:n]</code> directly, we avoid creating a variable in each loop.</li>
</ul>

<p>I would be interested to see how this performs in the standard tests with common hardware. I believe it will be well short of David Zhang's excellent algorithm in most tests, but should be quite fast otherwise.</p>

<p>I found this problem to be very counter-intuitive. The solutions I thought would be fast were slow. The solutions that looked slow were fast! It seems that Python's string creation with the multiply operator and string comparisons are highly optimised.</p>
"
29785400,,29481088.0,1354439.0,2,"<p>This function runs very quickly (tested and it's over 3 times faster than fastest solution here on strings with over 100k characters and the difference gets bigger the longer the repeating pattern is). It tries to minimise the number of comparisons needed to get the answer:</p>

<pre><code>def repeats(string):
    n = len(string)
    tried = set([])
    best = None
    nums = [i for i in  xrange(2, int(n**0.5) + 1) if n % i == 0]
    nums = [n/i for i in nums if n/i!=i] + list(reversed(nums)) + [1]
    for s in nums:
        if all(t%s for t in tried):
            print 'Trying repeating string of length:', s
            if string[:s]*(n/s)==string:
                best = s
            else:
                tried.add(s)
    if best:
        return string[:best]
</code></pre>

<p>Note that for example for string of length 8 it checks only fragment of size 4 and it does not have to test further because pattern of length 1 or 2 would result in repeating pattern of length 4:</p>

<pre><code>&gt;&gt;&gt; repeats('12345678')
Trying repeating string of length: 4
None

# for this one we need only 2 checks 
&gt;&gt;&gt; repeats('1234567812345678')
Trying repeating string of length: 8
Trying repeating string of length: 4
'12345678'
</code></pre>
"
29880583,,29481088.0,4784006.0,-1,"<p><em>Here is the code in python that checks for repetition of sub string in the main string given by the user</em>.</p>

<pre><code>print ""Enter a string....""
#mainstring = String given by user
mainstring=raw_input(""&gt;"")
if(mainstring==''):
    print ""Invalid string""
    exit()
#charlist = Character list of mainstring
charlist=list(mainstring)
strarr=''
print ""Length of your string :"",len(mainstring)
for i in range(0,len(mainstring)):
    strarr=strarr+charlist[i]
    splitlist=mainstring.split(strarr)
    count = 0
    for j in splitlist:
        if j =='':
            count+=1
    if count == len(splitlist):
        break
if count == len(splitlist):
    if count == 2:
        print ""No repeating Sub-String found in string %r""%(mainstring)

    else:
        print ""Sub-String %r repeats in string %r""%(strarr,mainstring)
else :
    print ""No repeating Sub-String found in string %r""%(mainstring)
</code></pre>

<p><em>Input</em>:  </p>

<blockquote>
  <p>0045662100456621004566210045662100456621  </p>
</blockquote>

<p><em>Output</em> :</p>

<blockquote>
  <p>Length of your string : 40    </p>
  
  <p>Sub-String '00456621' repeats in string '0045662100456621004566210045662100456621' </p>
</blockquote>

<p><em>Input</em> :</p>

<blockquote>
  <p>004608294930875576036866359447</p>
</blockquote>

<p><em>Output</em>:  </p>

<blockquote>
  <p>Length of your string : 30</p>
  
  <p>No repeating Sub-String found in string '004608294930875576036866359447'</p>
</blockquote>
"
17271319,Installing pip on Mac OS X,,2513263.0,873,"<p>I spent most of the day yesterday searching for a clear answer for installing pip. I can't find a good solution. </p>

<p>Can somebody help me install it?</p>
"
17271838,,17271319.0,2441252.0,216,"<p>You can install it through Homebrew on OS X.  Why would you install Python with Homebrew?</p>

<blockquote>
  <p>The version of Python that ships with OS X is great for learning but
  itâs not good for development. The version shipped with OS X may be
  out of date from the official current Python release, which is
  considered the stable production version. (<a href=""http://docs.python-guide.org/en/latest/starting/install/osx/"">source</a>)</p>
</blockquote>

<p>Homebrew is something of a package manager for OS X.  Find more details on the <a href=""http://mxcl.github.io/homebrew/"">Homebrew page</a>.  Once Homebrew is installed, run the following to install the latest Python, Pip &amp; Setuptools:</p>

<pre><code>brew install python
</code></pre>
"
18947390,,17271319.0,1399309.0,1619,"<p>All you need to do is</p>

<pre><code>sudo easy_install pip
</code></pre>
"
19128120,,17271319.0,2836869.0,9,"<pre><code>$ sudo port install py27-pip
</code></pre>

<p>Then update your PATH to include py27-pip bin directory (you can add this in ~/.bash_profile
PATH=/opt/local/Library/Frameworks/Python.framework/Versions/2.7/bin:$PATH</p>

<p>pip will be available in new terminal window.</p>
"
19607760,,17271319.0,1537388.0,17,"<p>You should install Brew first:</p>

<pre><code>ruby -e ""$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""
</code></pre>

<p>Then brew install Python</p>

<pre><code>brew install python
</code></pre>

<p>Then <code>pip</code> will work</p>
"
20829982,,17271319.0,1420498.0,57,"<p>The simplest solution is to follow the <a href=""http://www.pip-installer.org/en/latest/installing.html#install-or-upgrade-pip"">installation instruction from pip's home site</a>.</p>

<p>Basically, this consists in:</p>

<ul>
<li>downloading <a href=""https://raw.github.com/pypa/pip/master/contrib/get-pip.py"">get-pip.py</a>. Be sure to do this by following a trusted link since you will have to run the script as root.</li>
<li>call <code>sudo python get-pip.py</code></li>
</ul>

<p>The main advantage of that solution is that it install pip for the python version that has been used to run <code>get-pip.py</code>, which means that if you use the default OS X installation of python to run <code>get-pip.py</code> you will install pip for the python install from the system.</p>

<p>Most solutions that use a package manager (homebrew or macport) on OS X create a redundant installation of python in the environment of the package manager which can create inconsistencies in your system since, depending on what you are doing, you may call one installation of python instead of another.</p>
"
21655094,,17271319.0,440140.0,7,"<p>To install or upgrade <strong>pip</strong>, download <strong>get-pip.py</strong> from <a href=""http://www.pip-installer.org/en/latest/installing.html"">http://www.pip-installer.org/en/latest/installing.html</a></p>

<p>Then run the following:
<code>sudo python get-pip.py</code></p>

<p>For example:</p>

<pre><code>sudo python Desktop/get-pip.py 
Password:
  Downloading/unpacking pip
  Downloading pip-1.5.2-py2.py3-none-any.whl (1.2MB): 1.2MB downloaded
Installing collected packages: pip
Successfully installed pip
Cleaning up...

sudo pip install pymongo
Password:
Downloading/unpacking pymongo
  Downloading pymongo-2.6.3.tar.gz (324kB): 324kB downloaded
  Running setup.py (path:/private/var/folders/0c/jb79t3bx7cz6h7p71ydhwb_m0000gn/T/pip_build_goker/pymongo/setup.py) egg_info for package pymongo

Installing collected packages: pymongo
...
</code></pre>
"
25661467,,17271319.0,1479143.0,10,"<p>Download this file: <a href=""https://bootstrap.pypa.io/get-pip.py"">get-pip.py</a></p>

<p>Then simply type</p>

<pre><code>sudo python get-pip.py
</code></pre>

<p>Make sure you are on the same directory as get-pip.py or you supply the correct path for that file.</p>

<p>For details, you can visit: <a href=""http://pip.readthedocs.org/en/latest/installing.html"">http://pip.readthedocs.org/en/latest/installing.html</a></p>

<p>or, <a href=""http://thegauraw.tumblr.com/post/47601704154/how-to-install-pip-in-both-windows-ubuntu-easiest-way"">http://thegauraw.tumblr.com/post/47601704154/how-to-install-pip-in-both-windows-ubuntu-easiest-way</a> </p>
"
27287725,,17271319.0,3627034.0,67,"<p><code>pip</code> is available on OS X via <code>easy_install</code>.<br>
Open a terminal and type:</p>

<pre><code>sudo easy_install pip
</code></pre>

<p>When prompted for a password enter your normal login password.<br>
After the installation has completed you should be able to use <code>pip</code> as expected.   </p>

<p><em>note: this works for other python packages too</em></p>
"
28974427,,17271319.0,199166.0,27,"<p>Installing a separate copy of Python is a popular option, even though Python already comes with MacOS. You take on the responsibility to make sure you're using the copy of Python you intend. But, the benefits are having the latest Python release and some protection from hosing your system if things go badly wrong.</p>

<p>To install Python using <a href=""http://brew.sh/"">HomeBrew</a>:</p>

<pre><code>brew update
brew install python # or brew install python3
</code></pre>

<p>Now confirm that we're working with our newly installed Python:</p>

<pre><code>ls -lh `which python`
</code></pre>

<p>...should show a symbolic link to a path with ""Cellar"" in it like:</p>

<pre><code>lrwxr-xr-x  1 chris  admin    35B Dec  2 13:40 /usr/local/bin/python -&gt; ../Cellar/python/2.7.8_2/bin/python
</code></pre>

<p>Pip should be installed along with Python. You might want to upgrade it by typing:</p>

<pre><code>pip install --upgrade pip
</code></pre>

<p>Now you're ready to install any of the 50,000+ packages on <a href=""https://pypi.python.org/pypi"">PyPI</a>.</p>

<h3>Other Notes</h3>

<p>Formerly, I've used <a href=""https://pip.pypa.io/en/latest/installing.html"">get-pip.py to install pip</a>. But, the docs warn that get-pip.py does not coordinate with package managers and may leave your system in an inconsistent state. Anyway, there's no need, given that pip is now <a href=""https://docs.python.org/2.7//installing/index.html"">included with Python as of 2.7.9</a>.</p>

<p>Note that pip isn't the only package manager for Python. There's also easy_install. It's no good to mix the two, so don't do it.</p>

<p>Finally, if you have both Python 2 and 3 installed, <em>pip</em> will point to whichever Python you installed last. Get in the habit of explicitly using either <em>pip2</em> or <em>pip3</em>, so you're sure which Python is getting the new library.</p>

<p>Happy hacking!</p>
"
29188667,,17271319.0,2614911.0,91,"<p>It's Easy (On Mac):</p>

<ol>
<li><p>Install easy_install</p>

<pre><code>curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python
</code></pre></li>
<li><p>Install pip</p>

<pre><code>sudo easy_install pip
</code></pre></li>
<li><p>Now, you could install external modules. For example</p>

<pre><code>pip install regex   # This is only an example for installing other modules
</code></pre></li>
</ol>
"
36277291,,17271319.0,4057016.0,6,"<p>Download python setup tools from the below website:</p>

<p><a href=""https://pypi.python.org/pypi/setuptools"">https://pypi.python.org/pypi/setuptools</a></p>

<p>Use the tar file.</p>

<p>Once you download, go to the downloaded folder and run </p>

<pre><code>python setup.py install
</code></pre>

<p>Once you do that,you will have easy_install.</p>

<p>Use the below then to install pip:</p>

<pre><code>sudo easy_install pip
</code></pre>
"
38043109,,17271319.0,950111.0,39,"<p>OK, I read the solutions given above, but here's an <strong>EASY</strong> solution. </p>

<p>First of all, make sure you have <code>Python</code> installed. How? Open terminal and run the following command.</p>

<pre><code>python --version
</code></pre>

<p>If this command returns a version number that means python is already installed. That also means you already have access to <code>easy_install</code> considering you are using <code>OS X</code>.</p>

<p>Now, all you have to do is run the following command.</p>

<pre><code>sudo easy_install pip
</code></pre>

<p>After that, <code>pip</code> will be installed and you'll be able to use it for installing other packages.</p>
"
39442556,,17271319.0,2673464.0,5,"<p>I'm surprised no-one has mentioned this - it's a built-in way to install pip, without external tools or scripts:</p>

<pre><code>sudo python -m ensurepip
</code></pre>

<p>Works in pretty much the same way as <code>easy_install</code>, but worth knowing anyway.</p>
"
34857192,How to get urwid RadioButton and CheckBox values?,,520287.0,2,"<p>In <a href=""https://github.com/urwid/urwid/blob/master/examples/tour.py"" rel=""nofollow"">one of the urwid examples</a>, I'm trying to get and print user selected RadioButton and CheckBox values.</p>

<p>So far I have code below (python27) and can't figure out which object returns user's selection.</p>

<pre><code>import urwid
import urwid.raw_display
import urwid.web_display

def main():
    text_header = (u""hi!  ""
        u""UP / DOWN / PAGE UP / PAGE DOWN scroll.  F8 exits."")
    Radio_Text = [u""Select "",('important', u""one""), ]
    Multiselect_Text = [u""Select "",('important', u""many""), ]
    MultiSelect_Options = [u""Wax"", u""Wash"", u""Buff"", u""Clear Coat"", u""Dry"",
        u""Racing Stripe""]
    Radio_Options = [u""opt1"", u""opt2"", u""opt3"" ]

    def button_press(button):
        frame.footer = urwid.AttrWrap(urwid.Text(
            [u""Pressed: "", button.get_label()]), 'header')

    radio_button_group = []

    blank = urwid.Divider()
    listbox_content = [
        blank,
        urwid.Padding(urwid.Text(Radio_Text), left=2, right=2,
            min_width=20),
        blank,

        urwid.Padding(urwid.GridFlow(
            [urwid.AttrWrap(urwid.RadioButton(radio_button_group,
                txt), 'buttn','buttnf')
                for txt in Radio_Options],
            23, 7, 1, 'left') ,
            left=3, right=3, min_width=20),
        blank,
        urwid.Padding(urwid.Text(Multiselect_Text), left=2, right=2,
            min_width=20),
        blank,
        urwid.Padding(urwid.GridFlow(
            [urwid.AttrWrap(urwid.CheckBox(txt),'buttn','buttnf')
                for txt in MultiSelect_Options
        ],
            10, 3, 1, 'left') ,
            left=4, right=3, min_width=10),
        blank,
        blank,
        ]

    header = urwid.AttrWrap(urwid.Text(text_header), 'header')
    listbox = urwid.ListBox(urwid.SimpleListWalker(listbox_content))
    frame = urwid.Frame(urwid.AttrWrap(listbox, 'body'), header=header)

    palette = [
        ('body','black','light gray', 'standout'),
        ('reverse','light gray','black'),
        ('header','white','dark red', 'bold'),
        ('important','dark blue','light gray',('standout','underline')),
        ('editfc','white', 'dark blue', 'bold'),
        ('editbx','light gray', 'dark blue'),
        ('editcp','black','light gray', 'standout'),
        ('bright','dark gray','light gray', ('bold','standout')),
        ('buttn','black','dark cyan'),
        ('buttnf','white','dark blue','bold'),
        ]


    # use appropriate Screen class
    if urwid.web_display.is_web_request():
        screen = urwid.web_display.Screen()
    else:
        screen = urwid.raw_display.Screen()

    def unhandled(key):
        if key == 'f8':
            raise urwid.ExitMainLoop()

    urwid.MainLoop(frame, palette, screen,
        unhandled_input=unhandled).run()

def setup():
    urwid.web_display.set_preferences(""Urwid Tour"")
    # try to handle short web requests quickly
    if urwid.web_display.handle_short_request():
        return

    main()

if '__main__'==__name__ or urwid.web_display.is_web_request():
    setup()
</code></pre>
"
34920183,,34857192.0,520287.0,0,"<p>For the RadioButton state is stored in radio_button_group List.
CheckBoxes state can be retrieved from AttrWraps_list by invoking get_label and get_state</p>

<pre><code>import urwid
import urwid.raw_display
import urwid.web_display

def main():
    text_header = (u""hi!  ""
        u""UP / DOWN / PAGE UP / PAGE DOWN scroll.  F8 exits."")
    Radio_Text = [u""Select "",('important', u""one""), ]
    Multiselect_Text = [u""Select "",('important', u""many""), ]
    MultiSelect_Options = [u""Wax"", u""Wash"", u""Buff"", u""Clear Coat"", u""Dry"",
        u""Racing Stripe""]
    Radio_Options = [u""opt1"", u""opt2"", u""opt3"" ]

    def button_press(button):
        frame.footer = urwid.AttrWrap(urwid.Text(
            [u""Pressed: "", button.get_label()]), 'header')

    radio_button_group = []

    AttrWraps_list = [urwid.AttrWrap(urwid.CheckBox(txt),'buttn','buttnf') for txt in MultiSelect_Options]

    blank = urwid.Divider()
    listbox_content = [
        blank,
        urwid.Padding(urwid.Text(Radio_Text), left=2, right=2,
            min_width=20),
        blank,

        urwid.Padding(urwid.GridFlow(
            [urwid.AttrWrap(urwid.RadioButton(radio_button_group,
                txt), 'buttn','buttnf')
                for txt in Radio_Options],
            23, 7, 1, 'left') ,
            left=3, right=3, min_width=20),
        blank,
        urwid.Padding(urwid.Text(Multiselect_Text), left=2, right=2,
            min_width=20),
        blank,
        urwid.Padding(urwid.GridFlow(
            [urwid.AttrWrap(urwid.CheckBox(txt),'buttn','buttnf')
                for txt in MultiSelect_Options
        ],
            10, 3, 1, 'left') ,
            left=4, right=3, min_width=10),
        blank,
        blank,
        ]

    header = urwid.AttrWrap(urwid.Text(text_header), 'header')
    listbox = urwid.ListBox(urwid.SimpleListWalker(listbox_content))
    frame = urwid.Frame(urwid.AttrWrap(listbox, 'body'), header=header)

    palette = [
        ('body','black','light gray', 'standout'),
        ('reverse','light gray','black'),
        ('header','white','dark red', 'bold'),
        ('important','dark blue','light gray',('standout','underline')),
        ('editfc','white', 'dark blue', 'bold'),
        ('editbx','light gray', 'dark blue'),
        ('editcp','black','light gray', 'standout'),
        ('bright','dark gray','light gray', ('bold','standout')),
        ('buttn','black','dark cyan'),
        ('buttnf','white','dark blue','bold'),
        ]


    # use appropriate Screen class
    if urwid.web_display.is_web_request():
        screen = urwid.web_display.Screen()
    else:
        screen = urwid.raw_display.Screen()

    def unhandled(key):
        if key == 'f8':
            raise urwid.ExitMainLoop()
        if key == 'f5':
            txt = urwid.Text(str( {x.get_label(): x.get_state() for x in AttrWraps_list} ))            
            fill = urwid.Filler(txt, 'top')
            loop = urwid.MainLoop(fill)
            loop.run()

    urwid.MainLoop(frame, palette, screen,
        unhandled_input=unhandled).run()

def setup():
    urwid.web_display.set_preferences(""Urwid Tour"")
    # try to handle short web requests quickly
    if urwid.web_display.handle_short_request():
        return

    main()

if '__main__'==__name__ or urwid.web_display.is_web_request():
    setup()
</code></pre>
"
251464,How to get a function name as a string in Python?,,11452.0,306,"<p>In Python, how do I get a function name as a string without calling the function?</p>

<pre><code>def my_function():
    pass

print get_function_name_as_string(my_function) # my_function is not in quotes
</code></pre>

<p>should output <code>""my_function""</code>.</p>

<p>Is this available in python? If not, any idea how to write <code>get_function_name_as_string</code> in Python?</p>
"
251469,,251464.0,22364.0,32,"<pre><code>my_function.func_name
</code></pre>

<p>There are also other fun properties of functions. Type <code>dir(func_name)</code> to list them. <code>func_name.func_code.co_code</code> is the compiled function, stored as a string.</p>

<pre><code>import dis
dis.dis(my_function)
</code></pre>

<p>will display the code in <em>almost</em> human readable format. :)</p>
"
255297,,251464.0,28409.0,357,"<pre><code>my_function.__name__
</code></pre>

<p>Using <code>__name__</code> is the preferred method as it applies uniformly. Unlike <code>func_name</code>, it works on built-in functions as well:</p>

<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time.func_name
Traceback (most recent call last):
  File ""&lt;stdin&gt;"", line 1, in ?
AttributeError: 'builtin_function_or_method' object has no attribute 'func_name'
&gt;&gt;&gt; time.time.__name__ 
'time'
</code></pre>

<p>Also the double underscores indicate to the reader this is a special attribute. As a bonus, classes and modules have a <code>__name__</code> attribute too, so you only have remember one special name.</p>
"
13514318,,251464.0,1332764.0,116,"<p>You could also use</p>

<pre><code>import sys
this_function_name = sys._getframe().f_code.co_name
</code></pre>
"
18543271,,251464.0,2734604.0,6,"<p>sys._getframe() is not guaranteed to be available in all implementations of Python (<a href=""http://docs.python.org/2/library/sys.html"">see ref</a>) ,you can use the traceback module to do the same thing, eg.</p>

<pre><code>import traceback
def who_am_i():
   stack = traceback.extract_stack()
   filename, codeline, funcName, text = stack[-2]

   return funcName
</code></pre>

<p>A call to stack[-1] will return the current process details.</p>
"
20714270,,251464.0,937597.0,21,"<p>This function will return the caller's function name.</p>

<pre><code>def func_name():
    import traceback
    return traceback.extract_stack(None, 2)[0][2]
</code></pre>

<p>It is like Albert Vonpupp's answer with a friendly wrapper.</p>
"
25130006,,251464.0,3680588.0,-6,"<p>For readability, as string are highlighted by most editors, I would just create an object like this:</p>

<pre><code>def my_function():    
    f_name = 'my_function'
</code></pre>

<p>Which is less code characters than the ""correct"" way to fetch:</p>

<pre><code>def my_function():    
    f_name = my_function.__name__
</code></pre>

<p>seems needless if you're going to have to type out the function name anyway to access its </p>

<pre><code>.__name__ 
</code></pre>

<p>you don't just put the thing in quotes and call it good.</p>
"
36228241,,251464.0,109941.0,1,"<p>As an extension of <a href=""http://stackoverflow.com/a/20714270/109941"">@Demyn's answer</a>, I created some utility functions which print the current function's name and current function's arguments:</p>

<pre><code>import inspect
import logging
import traceback

def get_function_name():
    return traceback.extract_stack(None, 2)[0][2]

def get_function_parameters_and_values():
    frame = inspect.currentframe().f_back
    args, _, _, values = inspect.getargvalues(frame)
    return ([(i, values[i]) for i in args])

def my_func(a, b, c=None):
    logging.info('Running ' + get_function_name() + '(' + str(get_function_parameters_and_values()) +')')
    pass

logger = logging.getLogger()
handler = logging.StreamHandler()
formatter = logging.Formatter(
    '%(asctime)s [%(levelname)s] -&gt; %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.INFO)

my_func(1, 3) # 2016-03-25 17:16:06,927 [INFO] -&gt; Running my_func([('a', 1), ('b', 3), ('c', None)])
</code></pre>
"
38453402,,251464.0,797396.0,0,"<p>I  like using a function decorator.
I added a class, which also times the function time. Assume gLog is a standard python logger:</p>

<pre><code>class EnterExitLog():
    def __init__(self, funcName):
        self.funcName = funcName

    def __enter__(self):
        gLog.debug('Started: %s' % self.funcName)
        self.init_time = datetime.datetime.now()
        return self

    def __exit__(self, type, value, tb):
        gLog.debug('Finished: %s in: %s seconds' % (self.funcName, datetime.datetime.now() - self.init_time))

def func_timer_decorator(func):
    def func_wrapper(*args, **kwargs):
        with EnterExitLog(func.__name__):
            return func(*args, **kwargs)

    return func_wrapper
</code></pre>

<p>so now all you have to do with your function is decorate it and voila</p>

<pre><code>@func_timer_decorator
def my_func():
</code></pre>
"
19548011,Cannot install Lxml on Mac os x 10.9,,1788750.0,213,"<p>I want to install Lxml so I can then install Scrapy.</p>

<p>When I updated my Mac today it wouldn't let me reinstall lxml, I get the following error:</p>

<pre><code>In file included from src/lxml/lxml.etree.c:314:
/private/tmp/pip_build_root/lxml/src/lxml/includes/etree_defs.h:9:10: fatal error: 'libxml/xmlversion.h' file not found
#include ""libxml/xmlversion.h""
         ^
1 error generated.
error: command 'cc' failed with exit status 1
</code></pre>

<p>I have tried using brew to install libxml2 and libxslt, both installed fine but I still cannot install lxml.</p>

<p>Last time I was installing I needed to enable the developer tools on Xcode but since its updated to Xcode 5 it doesnt give me that option anymore.</p>

<p>Does anyone know what I need to do?</p>
"
19549645,,19548011.0,32198.0,24,"<p>This has been bothering me as well for a while.  I don't know the internals enough about python distutils etc, but the include path here is wrong.  I made the following ugly hack to hold me over until the python lxml people can do the proper fix.</p>

<pre><code>sudo ln -s  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2/libxml/ /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml
</code></pre>
"
19550278,,19548011.0,2670507.0,90,"<p>You may solve your problem by running this on the commandline:</p>

<pre><code> STATIC_DEPS=true pip install lxml
</code></pre>

<p>It sure helped me.
Explanations on <a href=""http://lxml.de/installation.html#using-lxml-with-python-libxml2"">docs</a></p>
"
19604913,,19548011.0,1884302.0,474,"<p>You should install or upgrade the commandline tool for xcode.
Try this in a terminal:</p>

<pre><code>xcode-select --install
</code></pre>
"
21581224,,19548011.0,1381190.0,-1,"<p>Try:</p>

<pre><code>% STATIC_DEPS=true pip install lxml
</code></pre>

<p>Or:</p>

<pre><code>% STATIC_DEPS=true sudo pip install lxml
</code></pre>

<p>It works!</p>
"
22333123,,19548011.0,467285.0,0,"<p>I am using OSX 10.9.2 and I get the same error.</p>

<p>Installation of the XCode command line tools does not help for this particular version of OSX.</p>

<p>I think a better approach to fix this is to install with the following command:</p>

<pre><code>$ CPATH=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2 pip install lxml
</code></pre>

<p>This is similar to jdkoftinoff' fix, but does not alter your system in a permanent way.</p>
"
22418820,,19548011.0,155293.0,11,"<p>instalation instructions on <a href=""http://lxml.de/installation.html"">http://lxml.de/installation.html</a> explain:</p>

<blockquote>
  <p>To speed up the build in test environments, e.g. on a continuous integration server, disable the C compiler optimisations by setting the CFLAGS environment variable:</p>
</blockquote>

<pre><code>CFLAGS=""-O0"" pip install lxml
</code></pre>
"
22791119,,19548011.0,142207.0,11,"<p>None of the above worked for me on 10.9.2, as compilation bails out with following error: </p>

<pre><code>clang: error: unknown argument: '-mno-fused-madd' 
</code></pre>

<p>Which actually lead to cleanest solution (see more details in [1]): </p>

<pre><code>export CFLAGS=-Qunused-arguments
export CPPFLAGS=-Qunused-arguments

pip install lxml
</code></pre>

<p>or following if installing globally</p>

<pre><code>sudo pip install lxml
</code></pre>

<p>[1] <a href=""http://stackoverflow.com/questions/22313407/clang-error-unknown-argument-mno-fused-madd-python-package-installation-fa"">clang error: unknown argument: &#39;-mno-fused-madd&#39; (python package installation failure)</a></p>
"
23005134,,19548011.0,337196.0,2,"<p>OSX 10.9.2</p>

<pre><code>sudo env ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future STATIC_DEPS=true pip install lxml
</code></pre>
"
23176666,,19548011.0,1445740.0,19,"<p>Installing globally... OS X 10.9.2</p>

<pre><code>xcode-select --install
sudo easy_install pip
sudo CPATH=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2 CFLAGS=-Qunused-arguments CPPFLAGS=-Qunused-arguments pip install lxml
</code></pre>
"
23690909,,19548011.0,2544437.0,2,"<p>I tried all the answers on this page, none of them worked for me. I'm running OS X Version 10.9.2</p>

<p>But this definitely works....like a charm:</p>

<p>ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future pip install lxml</p>
"
25934278,,19548011.0,3073764.0,0,"<p>I met the same question and after days of working I resolved this problem on my OS X 10.9.4, with Python 3.4.1.</p>

<p>Here's my solution,</p>

<p>According to <a href=""http://lxml.de/installation.html#using-lxml-with-python-libxml2"" rel=""nofollow"">installing lxml</a> from lxml.de,</p>

<blockquote>
  <p>A macport of lxml is available. Try something like port install py25-lxml</p>
</blockquote>

<p>If you do not have MacPort, install it from <a href=""https://www.macports.org/"" rel=""nofollow"">MacPort.org</a>. It's quite easy. You may also need a compiler, to install XCode compiling tools, use <strong><code>xcode-select --install</code></strong></p>

<p>Firstly I updated my port to the latest version via <strong><code>sudo port selfupdate</code></strong>, </p>

<p>Then I just type <strong><code>sudo port install libxml2</code></strong> and several minutes later you should see libxml2 installed successfully. Probably you may also need <code>libxslt</code> to install lxml. To install libxslt, use:<strong><code>sudo port install libxslt</code></strong>.</p>

<p>Now, just type <strong><code>pip install lxml</code></strong>, it should work fine.</p>
"
26544099,,19548011.0,11403.0,155,"<p>I solved this issue on Yosemite by both installing and linking <code>libxml2</code> and <code>libxslt</code> through brew:</p>

<pre><code>brew install libxml2
brew install libxslt
brew link libxml2 --force
brew link libxslt --force
</code></pre>

<p>If you have solved the problem using this method but it pops up again at a later time, you might need to run this <strong>before</strong> the four lines above:</p>

<pre><code>brew unlink libxml2
brew unlink libxslt
</code></pre>

<p>If you are having permission errors with Homebrew, especially on El Capitan, <a href=""https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/El_Capitan_and_Homebrew.md"">this is a helpful document</a>. In essence, regardless of OS X version, try running:</p>

<pre><code>sudo chown -R $(whoami):admin /usr/local
</code></pre>
"
26649365,,19548011.0,1297203.0,4,"<p>I solved this issue on <code>Yosemite</code> by running the following commands:</p>

<pre><code>xcode-select install #this may take several minutes.
pip install lxml
</code></pre>
"
26760713,,19548011.0,1095680.0,2,"<p>Unfortunately <code>xcode-select --install</code> did not work for me as I already had the latest version.</p>

<p>It's very strange but I solved the issue by opening XCode and accepting the Terms &amp; Conditions. Re-running <code>pip install lxml</code> returned no errors after.</p>
"
26831538,,19548011.0,3962110.0,47,"<p>I tried most of the solutions above, but none of them worked for me. I'm running Yosemite 10.10, the only solution that worked for me was to type this in the terminal:</p>

<pre><code>sudo CPATH=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2 CFLAGS=-Qunused-arguments CPPFLAGS=-Qunused-arguments pip install lxml
</code></pre>

<p>EDIT: If you are using virtualenv, the sudo in beginning is not needed.</p>
"
26832521,,19548011.0,834248.0,0,"<p>before compiling add the path that to xmlversion.h into your environment.</p>

<pre><code>$ set INCLUDE=$INCLUDE:/private/tmp/pip_build_root/lxml/src/lxml/
</code></pre>

<p>But make sure the path I've provided has the xmlversion.h file located inside. Then,</p>

<pre><code>$ python setup.py install
</code></pre>
"
27658815,,19548011.0,2798637.0,10,"<pre><code>xcode-select --install
sudo easy_install pip
sudo pip install lxml
</code></pre>
"
30879902,,19548011.0,1081043.0,0,"<p><code>pip</code> did not work for me. I went to
<a href=""https://pypi.python.org/pypi/lxml/2.3"" rel=""nofollow"">https://pypi.python.org/pypi/lxml/2.3</a>
and downloaded the macosx .egg file:</p>

<p><a href=""https://pypi.python.org/packages/2.7/l/lxml/lxml-2.3-py2.7-macosx-10.6-intel.egg#md5=52322e4698d68800c6b6aedb0dbe5f34"" rel=""nofollow"">https://pypi.python.org/packages/2.7/l/lxml/lxml-2.3-py2.7-macosx-10.6-intel.egg#md5=52322e4698d68800c6b6aedb0dbe5f34</a></p>

<p>Then used command line <code>easy_install</code> to install the <code>.egg</code> file.</p>
"
37435766,,19548011.0,2241364.0,2,"<p>With homebrew, libxml2 is hidden to not interfere with the system libxml2, so pip must be helped a little in order to find it.</p>

<p>With bash:</p>

<pre><code>LDFLAGS=-L`brew --prefix libxml2`/lib CPPFLAGS=-I`brew --prefix libxml2`/include/libxml2 pip install --user lxml
</code></pre>

<p>With fish:</p>

<pre><code>env LDFLAGS=-L(brew --prefix libxml2)/lib CPPFLAGS=-I(brew --prefix libxml2)/include/libxml2 pip install --user lxml
</code></pre>
"
39234690,,19548011.0,1183098.0,0,"<p>This post links to a solution that worked for me
<a href=""http://stackoverflow.com/questions/23586239/python3-lxml-and-symbol-not-found-lzma-auto-decoder-on-mac-os-x-10-9/39276990#39276990"">Python3, lxml and &quot;Symbol not found: _lzma_auto_decoder&quot; on Mac OS X 10.9</a></p>

<p>hth</p>
"
415511,How to get current time in Python,,46646.0,1153,"<p>What is the module/method used to get current time?</p>
"
415519,,415511.0,1057.0,1151,"<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.datetime.now()
datetime(2009, 1, 6, 15, 8, 24, 78915)
</code></pre>

<p>And just the time:</p>

<pre><code>&gt;&gt;&gt; datetime.datetime.time(datetime.datetime.now())
datetime.time(15, 8, 24, 78915)
</code></pre>

<p>The same but slightly more compact:</p>

<pre><code>&gt;&gt;&gt; datetime.datetime.now().time()
</code></pre>

<p>See the <a href=""https://docs.python.org/3/library/datetime.html""><strong>documentation</strong></a> for more info.</p>

<p>To save typing, you can import the <code>datetime</code> object from the <code>datetime</code> module:</p>

<pre><code>&gt;&gt;&gt; from datetime import datetime
</code></pre>

<p>Then remove the leading <code>datetime.</code> from all the above.</p>
"
415525,,415511.0,51071.0,475,"<p>You can use <a href=""http://docs.python.org/3.3/library/time.html?highlight=time.strftime#time.strftime""><code>time.strftime()</code></a>:    </p>

<pre><code>&gt;&gt;&gt; from time import gmtime, strftime
&gt;&gt;&gt; strftime(""%Y-%m-%d %H:%M:%S"", gmtime())
'2009-01-05 22:14:39'
</code></pre>
"
415527,,415511.0,27474.0,66,"<pre><code>&gt;&gt;&gt; from time import gmtime, strftime
&gt;&gt;&gt; strftime(""%a, %d %b %Y %X +0000"", gmtime())
'Tue, 06 Jan 2009 04:54:56 +0000'
</code></pre>

<p>That outputs the current GMT in the specified format. There is also a localtime() method. </p>

<p>This <a href=""http://docs.python.org/library/time.html#module-time"">page</a> has more details.</p>
"
416605,,415511.0,21152.0,74,"<p>Do</p>

<pre><code>from time import time

t = time()
</code></pre>

<ul>
<li><code>t</code> - float number, good for time interval measurement.</li>
</ul>

<p>There is some difference for Unix and Windows platforms.</p>
"
4538034,,415511.0,505893.0,26,"<p>If you need current time as a <code>time</code> object:</p>

<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; now = datetime.datetime.now()
&gt;&gt;&gt; datetime.time(now.hour, now.minute, now.second)
datetime.time(11, 23, 44)
</code></pre>
"
5877368,,415511.0,4872.0,222,"<p>Similar to <a href=""http://stackoverflow.com/questions/415511/how-to-get-current-time-in-python/415519#415519"">Harley's answer</a>, but use the <code>str()</code> function for a quick-n-dirty, slightly more human readable format:</p>

<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; str(datetime.now())
'2011-05-03 17:45:35.177000'
</code></pre>
"
14229023,,415511.0,1192220.0,175,"<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.now().strftime('%Y-%m-%d %H:%M:%S')
</code></pre>

<p>For this example, the output will be like this: <code>'2013-09-18 11:16:32'</code></p>

<p>The format for <code>strftime</code> is at:<br>
<a href=""https://docs.python.org/2/library/time.html#time.strftime"">https://docs.python.org/2/library/time.html#time.strftime</a></p>
"
17287377,,415511.0,1415599.0,16,"<p>I'll contribute to this because <code>.isoformat()</code> is in the documentation but not yet here
(this is mighty similar to @Ray Vega's answer):</p>

<pre><code>&gt;&gt;&gt;import datetime
&gt;&gt;&gt; datetime.datetime.now().isoformat()
'2013-06-24T20:35:55.982000'
</code></pre>
"
18980227,,415511.0,1047510.0,13,"<p>Quickest way is</p>

<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; time.strftime(""%Y%m%d"")
'20130924'
</code></pre>
"
19710846,,415511.0,1546600.0,27,"<p>All good suggestions, but I find it easiest to use <code>ctime()</code> myself:</p>

<pre><code>In [2]: from time import ctime
In [3]: ctime()
Out[3]: 'Thu Oct 31 11:40:53 2013'
</code></pre>

<p>This gives a nicely formatted string representation of current local time.</p>
"
23753208,,415511.0,2030113.0,5,"<pre><code>&gt;&gt;&gt; import datetime, time
&gt;&gt;&gt; time = strftime(""%H:%M:%S:%MS"", time.localtime())
&gt;&gt;&gt; print time
'00:20:58:20S'
</code></pre>
"
27611645,,415511.0,4279.0,8,"<p><code>datetime.now()</code> returns the current time as a naive datetime object that represents time in the local timezone. That value may be ambiguous e.g., during DST transitions (""fall back""). To avoid ambiguity either UTC timezone should be used:</p>

<pre><code>from datetime import datetime

utc_time = datetime.utcnow()
print(utc_time) # -&gt; 2014-12-22 22:48:59.916417
</code></pre>

<p>Or a timezone-aware object that has the corresponding timezone info attached (Python 3.2+):</p>

<pre><code>from datetime import datetime, timezone

now = datetime.now(timezone.utc).astimezone()
print(now) # -&gt; 2014-12-23 01:49:25.837541+03:00
</code></pre>
"
27866830,,415511.0,1899063.0,11,"<p>This is what I ended up going with: </p>

<pre><code>&gt;&gt;&gt;from time import strftime
&gt;&gt;&gt;strftime(""%m/%d/%Y %H:%M"")
01/09/2015 13:11
</code></pre>

<p>Also, this table is a necessary reference for choosing the appropriate format codes to get the date formatted just the way you want it (from Python ""datetime"" documentation <a href=""https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior"">here</a>).</p>

<p><img src=""http://i.stack.imgur.com/i6Hg7.jpg"" alt=""strftime format code table""></p>
"
28371709,,415511.0,3780935.0,6,"<p>You can use the time module.</p>

<pre><code>import time
print time.strftime(""%d/%m/%Y"")

&gt;&gt;&gt; 06/02/2015
</code></pre>

<p>The use of the captial <code>Y</code> gives the full year, using <code>y</code> would give <code>06/02/15</code></p>

<p>You could also use to give a more lengthy time.</p>

<pre><code>time.strftime(""%a, %d %b %Y %H:%M:%S"")
&gt;&gt;&gt; 'Fri, 06 Feb 2015 17:45:09'
</code></pre>
"
28576383,,415511.0,541136.0,38,"<blockquote>
  <h1>How do I get the current time in Python?</h1>
</blockquote>

<h2>The <code>time</code> module</h2>

<p>The <code>time</code> module provides functions that tells us the time in ""seconds since the epoch"" as well as other utilities.</p>

<pre><code>import time
</code></pre>

<h3>Unix Epoch Time</h3>

<p>This is the format you should get timestamps in for saving in databases. It is a simple floating point number that can be converted to an integer. It is also good for arithmetic in seconds, as it represents the number of seconds since Jan 1, 1970 00:00:00, and it is memory light relative to the other representations of time we'll be looking at next:</p>

<pre><code>&gt;&gt;&gt; time.time()
1424233311.771502
</code></pre>

<p>This timestamp does not account for leap-seconds, so it's not linear - leap seconds are ignored. So while it is not equivalent to the international UTC standard, it is close, and therefore quite good for most cases of record-keeping. </p>

<p>This is not ideal for human scheduling, however. If you have a future event you wish to take place at a certain point in time, you'll want to store that time with a string that can be parsed into a datetime object or a serialized datetime object (these will be described later).</p>

<h3><code>time.ctime</code></h3>

<p>You can also represent the current time in the way preferred by your operating system (which means it can change when you change your system preferences, so don't rely on this to be standard across all systems, as I've seen others expect). This is typically user friendly, but doesn't typically result in strings one can sort chronologically:</p>

<pre><code>&gt;&gt;&gt; time.ctime()
'Tue Feb 17 23:21:56 2015'
</code></pre>

<p>You can hydrate timestamps into human readable form with <code>ctime</code> as well:</p>

<pre><code>&gt;&gt;&gt; time.ctime(1424233311.771502)
'Tue Feb 17 23:21:51 2015'
</code></pre>

<p>This conversion is also not good for record-keeping (except in text that will only be parsed by humans - and with improved Optical Character Recognition and Artificial Intelligence, I think the number of these cases will diminish).</p>

<h2><code>datetime</code> module</h2>

<p>The <code>datetime</code> module is also quite useful here:</p>

<pre><code>&gt;&gt;&gt; import datetime
</code></pre>

<h3><code>datetime.datetime.now</code></h3>

<p>The <code>datetime.now</code> is a class method that returns the current time. It uses the <code>time.localtime</code> without the timezone info (if not given, otherwise see timezone aware below). It has a representation (which would allow you to recreate an equivalent object) echoed on the shell, but when printed (or coerced to a <code>str</code>), it is in human readable (and nearly ISO) format, and the lexicographic sort is equivalent to the chronological sort:</p>

<pre><code>&gt;&gt;&gt; datetime.datetime.now()
datetime.datetime(2015, 2, 17, 23, 43, 49, 94252)
&gt;&gt;&gt; print(datetime.datetime.now())
2015-02-17 23:43:51.782461
</code></pre>

<h3>datetime's <code>utcnow</code></h3>

<p>You can get a datetime object in UTC time, a global standard, by doing this:</p>

<pre><code>&gt;&gt;&gt; datetime.datetime.utcnow()
datetime.datetime(2015, 2, 18, 4, 53, 28, 394163)
&gt;&gt;&gt; print(datetime.datetime.utcnow())
2015-02-18 04:53:31.783988
</code></pre>

<p>UTC is a time standard that is nearly equivalent to the GMT timezone. (While GMT and UTC do not change for Daylight Savings Time, their users may switch to other timezones, like British Summer Time, during the Summer.) </p>

<h3>datetime timezone aware</h3>

<p>However, none of the datetime objects we've created so far can be easily converted to various timezones. We can solve that problem with the <code>pytz</code> module:</p>

<pre><code>&gt;&gt;&gt; import pytz
&gt;&gt;&gt; then = datetime.datetime.now(pytz.utc)
&gt;&gt;&gt; then
datetime.datetime(2015, 2, 18, 4, 55, 58, 753949, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>Equivalently, in Python 3 we have the <code>timezone</code> class with a utc <code>timezone</code> instance attached, which also makes the object timezone aware (but to convert to another timezone without the handy <code>pytz</code> module is left as an exercise to the reader):</p>

<pre><code>&gt;&gt;&gt; datetime.datetime.now(datetime.timezone.utc)
datetime.datetime(2015, 2, 18, 22, 31, 56, 564191, tzinfo=datetime.timezone.utc)
</code></pre>

<p>And we see we can easily convert to timezones from the original utc object.</p>

<pre><code>&gt;&gt;&gt; print(then)
2015-02-18 04:55:58.753949+00:00
&gt;&gt;&gt; print(then.astimezone(pytz.timezone('US/Eastern')))
2015-02-17 23:55:58.753949-05:00
</code></pre>

<p>You can also make a naive datetime object aware with the <code>pytz</code> timezone <code>localize</code> method, or by replacing the tzinfo attribute (with <code>replace</code>, this is done blindly), but these are more last resorts than best practices:</p>

<pre><code>&gt;&gt;&gt; pytz.utc.localize(datetime.datetime.utcnow())
datetime.datetime(2015, 2, 18, 6, 6, 29, 32285, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; datetime.datetime.utcnow().replace(tzinfo=pytz.utc)
datetime.datetime(2015, 2, 18, 6, 9, 30, 728550, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>The <code>pytz</code> module allows us to make our <code>datetime</code> objects timezone aware and convert the times to the hundreds of timezones available in the <code>pytz</code> module.</p>

<p>One could ostensibly serialize this object for UTC time and store <em>that</em> in a database, but it would require far more memory and be more prone to error than simply storing the Unix Epoch time, which I demonstrated first. </p>

<p>The other ways of viewing times are much more error prone, especially when dealing with data that may come from different time zones. You want there to be no confusion as to which timezone a string or serialized datetime object was intended for.</p>

<p>If you're displaying the time with Python for the user, <code>ctime</code> works nicely, not in a table (it doesn't typically sort well), but perhaps in a clock. However, I personally recommend, when dealing with time in Python, either using Unix time, or a timezone aware UTC <code>datetime</code> object. </p>
"
29980465,,415511.0,4224901.0,2,"<p>This is what i use to get the time without having to format , some people dont like the split method but it is useful here :</p>

<pre><code>from time import ctime
print ctime().split()[3]
</code></pre>

<p>Will print in HH:MM:SS format</p>
"
33704374,,415511.0,1499803.0,6,"<p>Try the arrow module from <a href=""http://crsmithdev.com/arrow/"">http://crsmithdev.com/arrow/</a></p>

<pre><code>import arrow
arrow.now()
</code></pre>

<p>or the utc version</p>

<pre><code>arrow.utcnow()
</code></pre>

<p>to change it's output add .format()</p>

<pre><code>arrow.utcnow().format('YYYY-MM-DD HH:mm:ss ZZ')
</code></pre>

<p>for a specific timezone?</p>

<pre><code>arrow.now('US/Pacific')
</code></pre>

<p>an hour ago</p>

<pre><code>arrow.utcnow().replace(hours=-1)
</code></pre>

<p>or if you want the gist.</p>

<pre><code>arrow.get('2013-05-11T21:23:58.970460+00:00').humanize()
&gt;&gt;&gt; '2 years ago'
</code></pre>
"
38366394,,415511.0,4972892.0,0,"<pre><code>import datetime
date_time = str(datetime.datetime.now())
date = date_time.split()[0]
time = date_time.split()[1]
</code></pre>

<p>date will print date and time will print time.</p>
"
38433505,,415511.0,867889.0,0,"<p>I am a simple man and i want time with milliseconds. Simple way to get them:</p>

<pre><code>import time, datetime

print(datetime.datetime.now().time())                         # 11:20:08.272239
# or in a more complicated way
print(datetime.datetime.now().time().isoformat())             # 11:20:08.272239
print(datetime.datetime.now().time().strftime('%H:%M:%S.%f')) # 11:20:08.272239
# but do not use this
print(time.strftime(""%H:%M:%S.%f"", time.localtime()), str)    # 11:20:08.%f
</code></pre>

<p>But i want <strong>only miliseconds</strong>, right? Shortest way to get them:</p>

<pre><code>import time

time.strftime(""%H:%M:%S"", time.localtime()) + '.%d' % (time.time() % 1 * 1000)
# 11:34:23.751
</code></pre>

<p>Add or remove zeroes from the last multiplication to adjust number of decimal points, or just:</p>

<pre><code>def get_time_str(decimal_points=3):
    return time.strftime(""%H:%M:%S"", time.localtime()) + '.%d' % (time.time() % 1 * 10**decimal_points)
</code></pre>
"
38615092,,415511.0,1312261.0,5,"<p>why not just keep things simple. </p>

<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
'2016-07-27 15:56:59'
&gt;&gt;&gt;
</code></pre>
"
39046637,,415511.0,2573061.0,5,"<p>Why not ask the <a href=""http://tycho.usno.navy.mil/cgi-bin/timer.pl"">U.S. Naval Observatory</a>, the official timekeeper of the United States Navy?</p>

<pre><code>import requests
from lxml import html

page = requests.get('http://tycho.usno.navy.mil/cgi-bin/timer.pl')
tree = html.fromstring(page.content)
print(tree.xpath('//html//body//h3//pre/text()')[1])
</code></pre>

<p>If you live in the D.C. area (like me) the latency might not be too bad...</p>
"
7225900,How to pip install packages according to requirements.txt from a local directory?,,496852.0,385,"<p>Here is the problem</p>

<p>I have a requirements.txt that looks like:</p>

<pre><code>BeautifulSoup==3.2.0
Django==1.3
Fabric==1.2.0
Jinja2==2.5.5
PyYAML==3.09
Pygments==1.4
SQLAlchemy==0.7.1
South==0.7.3
amqplib==0.6.1
anyjson==0.3
...
</code></pre>

<p>I have a local archive directory containing all the packages + others.</p>

<p>I have created a new virtualenv with</p>

<pre><code>bin/virtualenv testing
</code></pre>

<p>upon activating it, I tried to install the packages according to requirements.txt from the local archive directory.</p>

<pre><code>source bin/activate
pip install -r /path/to/requirements.txt -f file:///path/to/archive/
</code></pre>

<p>I got some output that seems to indicate that the installation is fine</p>

<pre><code>Downloading/unpacking Fabric==1.2.0 (from -r ../testing/requirements.txt (line 3))
  Running setup.py egg_info for package Fabric
    warning: no previously-included files matching '*' found under directory 'docs/_build'
    warning: no files found matching 'fabfile.py'
Downloading/unpacking South==0.7.3 (from -r ../testing/requirements.txt (line 8))
  Running setup.py egg_info for package South
....
</code></pre>

<p>But later check revealed none of the package is installed properly. I cannot import the package, and none is found in the site-packages directory of my virtualenv. So what went wrong?</p>
"
10429168,,7225900.0,3571.0,165,"<p>This works for me:</p>

<pre><code>$ pip install -r requirements.txt --no-index --find-links file:///tmp/packages
</code></pre>
"
15593865,,7225900.0,710332.0,605,"<p>I've read the above, realize this is an old question, but it's totally unresolved and still at the top of my google search results so here's an answer that works for everyone:</p>

<pre><code>pip install -r /path/to/requirements.txt
</code></pre>
"
22046133,,7225900.0,1913888.0,77,"<p>For virtualenv to install all files in the requirements.txt file.</p>

<ol>
<li>cd to the directory where  requirements.txt is located</li>
<li>activate your virtualenv</li>
<li>run:  <code>pip install -r requirements.txt</code>  in your shell</li>
</ol>
"
30498549,,7225900.0,4358680.0,-3,"<p>I realize this might be a little long drawn but if they are in the same directory as your code you can :</p>

<pre><code>import BeautifulSoup as bs
import Django as dj
import Fabric as fb
</code></pre>

<p>That way you can utilize all the specific packages you want.</p>

<p>This is a work around and not utilizing virtualenv but I can confirm this works 100% of the time.</p>
"
32709817,,7225900.0,454023.0,7,"<p>Often, you will want a fast install from local archives, without probing PyPI.</p>

<p>First, download the archives that fulfill your requirements:</p>

<pre><code>$ pip install --download &lt;DIR&gt; -r requirements.txt
</code></pre>

<p>Then, install using <code>âfind-links</code> and <code>âno-index</code>:</p>

<pre><code>$ pip install --no-index --find-links=[file://]&lt;DIR&gt; -r requirements.txt
</code></pre>
"
34969495,,7225900.0,4694928.0,25,"<p>I had a similar problem. I tried this:</p>

<pre><code>pip install -U -r requirements.txt 
</code></pre>

<p><em>(-U = update if it had already installed)</em></p>

<p>But the problem continued. I realized that some of generic libraries for development were missed.</p>

<pre><code>sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk
</code></pre>

<p>I don't know if this would help you.</p>
"
39537053,,7225900.0,5915952.0,0,"<p><strong>pip install -r requirements.txt</strong></p>

<p>For further details please check the help option.</p>

<p>pip install --help</p>

<p>We can find the option '-r'</p>

<blockquote>
  <p>-r, --requirement     Install from the given requirements file. This option can be
                                used multiple times.</p>
</blockquote>

<p>Further information on some commonly used pip install options: (This is the help option on pip install command)</p>

<p><a href=""http://i.stack.imgur.com/NWTio.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/NWTio.png"" alt=""enter image description here""></a></p>

<p>Also the above is the complete set of options. Please use pip install --help for complete list of options.</p>
"
12863503,Sublime Text 2 add module for PlugIn (MySQLdb),,549010.0,3,"<p>Im developing a small plugin for Sublime Text 2, but i need to use MySQLdb module. The MySQLdb module works fine from my normal CLI. But SB2 uses its own version of Python. </p>

<p>Any idea <strong>how</strong> i can install the MySQKdb module and <strong>where</strong> so SB2 can find it?</p>

<p>Python installation used /System/Library/Frameworks/Python.framework/Versions/2.7/</p>

<p>Thanks!</p>
"
14694849,,12863503.0,363.0,1,"<p>I was working on a plug-in today, and the solution I chose was to place the module within my package directory. In otherwords:</p>

<pre><code>Packages
|  MyPackage
|  |  MyPackage.py
|  |  MySQLdb
|  |  | contents of MySQLdb package
</code></pre>

<p>You can change the PYTHONPATH that Sublime Text 2 uses, per these posts, but it seems there may be compatibility issues if you aren't careful.</p>

<p><a href=""http://stackoverflow.com/questions/8574919/sublime-text-2-custom-path-and-pythonpath"">Sublime Text 2: custom PATH and PYTHONPATH</a></p>

<p><a href=""http://stackoverflow.com/questions/13239839/sublime-text2-import-error-no-module-named-gnuplot"">Sublime Text2 Import error: No module named Gnuplot</a></p>

<p>This leads me to believe that the best solution would be to create a folder specifically for  downloading modules solely for the use of Sublime Text 2, and adding that to Sublime Text's PYTHONPATH.</p>
"
1823058,How to print number with commas as thousands separators?,,28324.0,290,"<p>I am trying to print an integer in <em>Python 2.6.1</em> with commas as thousands separators. For example, I want to show the number <code>1234567</code> as <code>1,234,567</code>. How would I go about doing this? I have seen many examples on Google, but I am looking for the simplest practical way.</p>

<p>It does not need to be locale-specific to decide between periods and commas. I would prefer something as simple as reasonably possible.</p>
"
1823089,,1823058.0,61974.0,11,"<p>I'm sure there must be a standard library function for this, but it was fun to try to write it myself using recursion so here's what I came up with:</p>

<pre><code>def intToStringWithCommas(x):
    if type(x) is not int and type(x) is not long:
        raise TypeError(""Not an integer!"")
    if x &lt; 0:
        return '-' + intToStringWithCommas(-x)
    elif x &lt; 1000:
        return str(x)
    else:
        return intToStringWithCommas(x / 1000) + ',' + '%03d' % (x % 1000)
</code></pre>

<p>Having said that, if someone else does find a standard way to do it, you should use that instead.</p>
"
1823101,,1823058.0,2624511.0,198,"<p>I got this to work:</p>

<pre><code>&gt;&gt;&gt; import locale
&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'en_US')
'en_US'
&gt;&gt;&gt; locale.format(""%d"", 1255000, grouping=True)
'1,255,000'
</code></pre>

<p>Sure, you don't <em>need</em> internationalization support, but it's clear, concise, and uses a built-in library.</p>

<p>P.S. That ""%d"" is the usual %-style formatter.  You can have only one formatter, but it can be whatever you need in terms of field width and precision settings.</p>

<p>P.P.S. If you can't get <code>locale</code> to work, I'd suggest a modified version of Mark's answer:</p>

<pre><code>def intWithCommas(x):
    if type(x) not in [type(0), type(0L)]:
        raise TypeError(""Parameter must be an integer."")
    if x &lt; 0:
        return '-' + intWithCommas(-x)
    result = ''
    while x &gt;= 1000:
        x, r = divmod(x, 1000)
        result = "",%03d%s"" % (r, result)
    return ""%d%s"" % (x, result)
</code></pre>

<p>Recursion is useful for the negative case, but one recursion per comma seems a bit excessive to me.</p>
"
1823113,,1823058.0,120991.0,0,"<p>Just subclass long (or float, or whatever). This is highly practical, because this way you can still use your numbers in math ops (and therefore existing code), but they will all print nicely in your terminal. </p>

<pre><code>&gt;&gt;&gt; class number(long):

        def __init__(self, value):
            self = value

        def __repr__(self):
            s = str(self)
            l = [x for x in s if x in '1234567890']
            for x in reversed(range(len(s)-1)[::3]):
                l.insert(-x, ',')
            l = ''.join(l[1:])
            return ('-'+l if self &lt; 0 else l) 

&gt;&gt;&gt; number(-100000)
-100,000
&gt;&gt;&gt; number(-100)
-100
&gt;&gt;&gt; number(-12345)
-12,345
&gt;&gt;&gt; number(928374)
928,374
&gt;&gt;&gt; 345
</code></pre>
"
1823189,,1823058.0,97828.0,73,"<p>Here is the locale grouping code after removing irrelevant parts and cleaning it up a little:</p>

<p>(The following only works for integers)</p>

<pre><code>def group(number):
    s = '%d' % number
    groups = []
    while s and s[-1].isdigit():
        groups.append(s[-3:])
        s = s[:-3]
    return s + ','.join(reversed(groups))

&gt;&gt;&gt; group(-23432432434.34)
'-23,432,432,434'
</code></pre>

<hr>

<p>There are already some good answers in here. I just want to add this for future reference. In python 2.7 there is going to be a format specifier for thousands separator. According to <a href=""http://docs.python.org/dev/whatsnew/2.7.html#pep-378-format-specifier-for-thousands-separator"">python docs</a> it works like this</p>

<pre><code>&gt;&gt;&gt; '{:20,.2f}'.format(f)
'18,446,744,073,709,551,616.00'
</code></pre>

<p>In python3.1 you can do the same thing like this:</p>

<pre><code>&gt;&gt;&gt; format(1234567, ',d')
'1,234,567'
</code></pre>
"
4113289,,1823058.0,296637.0,2,"<p>Here's one that works for floats too:</p>

<pre><code>def float2comma(f):
    s = str(abs(f)) # Convert to a string
    decimalposition = s.find(""."") # Look for decimal point
    if decimalposition == -1:
        decimalposition = len(s) # If no decimal, then just work from the end
    out = """" 
    for i in range(decimalposition+1, len(s)): # do the decimal
        if not (i-decimalposition-1) % 3 and i-decimalposition-1: out = out+"",""
        out = out+s[i]      
    if len(out):
        out = "".""+out # add the decimal point if necessary
    for i in range(decimalposition-1,-1,-1): # working backwards from decimal point
        if not (decimalposition-i-1) % 3 and decimalposition-i-1: out = "",""+out
        out = s[i]+out      
    if f &lt; 0:
        out = ""-""+out
    return out
</code></pre>

<p>Usage Example:</p>

<pre><code>&gt;&gt;&gt; float2comma(10000.1111)
'10,000.111,1'
&gt;&gt;&gt; float2comma(656565.122)
'656,565.122'
&gt;&gt;&gt; float2comma(-656565.122)
'-656,565.122'
</code></pre>
"
4205875,,1823058.0,15890.0,8,"<p>From the <a href=""http://code.activestate.com/recipes/498181-add-thousands-separator-commas-to-formatted-number/#c3"">comments</a> to activestate recipe <a href=""http://code.activestate.com/recipes/498181-add-thousands-separator-commas-to-formatted-number/"">498181</a> I reworked this:</p>

<pre><code>import re
def thous(x, sep=',', dot='.'):
    num, _, frac = str(x).partition(dot)
    num = re.sub(r'(\d{3})(?=\d)', r'\1'+sep, num[::-1])[::-1]
    if frac:
        num += dot + frac
    return num
</code></pre>

<p>It uses the regular expressions feature: <a href=""http://docs.python.org/howto/regex.html#lookahead-assertions"">lookahead</a> i.e. <code>(?=\d)</code> to make sure only groups of three digits that have a digit 'after' them get a comma. I say 'after' because the string is reverse at this point.</p>

<p><code>[::-1]</code> just reverses a string.</p>
"
8571035,,1823058.0,1107160.0,-4,"<p>For floats:</p>

<pre><code>float(filter(lambda x: x!=',', '1,234.52'))
# returns 1234.52
</code></pre>

<p>For ints:</p>

<pre><code>int(filter(lambda x: x!=',', '1,234'))
# returns 1234
</code></pre>
"
8932161,,1823058.0,1028595.0,63,"<p>For inefficiency and unreadability it's hard to beat:</p>

<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; s = '-1234567'
&gt;&gt;&gt; ','.join([""%s%s%s"" % (x[0], x[1] or '', x[2] or '') for x in itertools.izip_longest(s[::-1][::3], s[::-1][1::3], s[::-1][2::3])])[::-1].replace('-,','-')
</code></pre>
"
9505119,,1823058.0,289255.0,-6,"<p>If you don't want to depend on any external libraries:</p>

<pre><code> s = str(1234567)
 print ','.join([s[::-1][k:k+3][::-1] for k in xrange(len(s)-1, -1, -3)])
</code></pre>

<p>This works only for non-negative integers.</p>
"
10742904,,1823058.0,1415726.0,807,"<p>I too, prefer the ""simplest practical way"". For >= 2.7:</p>

<pre><code>""{:,}"".format(value)
</code></pre>

<p><a href=""http://docs.python.org/library/string.html#format-specification-mini-language"">http://docs.python.org/library/string.html#format-specification-mini-language</a></p>
"
11149343,,1823058.0,1454536.0,1,"<p>I'm using python 2.5 so I don't have access to the built-in formatting.</p>

<p>I looked at the django code intcomma (intcomma_recurs in code below) and realized it's inefficient, because it's recursive and also compiling the regex on every run is not a good thing either.  This is not necessary an 'issue' as django isn't really THAT focused on this kind of low-level performance.  Also, I was expecting a factor of 10 difference in performance, but it's only 3 times slower.</p>

<p>Out of curiosity I implemented a few versions of intcomma to see what the performance advantages are when using regex.  My test data concludes a slight advantage for this task, but surprisingly not much at all.</p>

<p>I also was pleased to see what I suspected: using the reverse xrange approach is unnecessary in the no-regex case, but it does make the code look slightly better at the cost of ~10% performance.</p>

<p>Also, I assume what you're passing in is a string and looks somewhat like a number.  Results undetermined otherwise.</p>

<pre><code>from __future__ import with_statement
from contextlib import contextmanager
import re,time

re_first_num = re.compile(r""\d"")
def intcomma_noregex(value):
    end_offset, start_digit, period = len(value),re_first_num.search(value).start(),value.rfind('.')
    if period == -1:
        period=end_offset
    segments,_from_index,leftover = [],0,(period-start_digit) % 3
    for _index in xrange(start_digit+3 if not leftover else start_digit+leftover,period,3):
        segments.append(value[_from_index:_index])
        _from_index=_index
    if not segments:
        return value
    segments.append(value[_from_index:])
    return ','.join(segments)

def intcomma_noregex_reversed(value):
    end_offset, start_digit, period = len(value),re_first_num.search(value).start(),value.rfind('.')
    if period == -1:
        period=end_offset
    _from_index,segments = end_offset,[]
    for _index in xrange(period-3,start_digit,-3):
        segments.append(value[_index:_from_index])
        _from_index=_index
    if not segments:
        return value
    segments.append(value[:_from_index])
    return ','.join(reversed(segments))

re_3digits = re.compile(r'(?&lt;=\d)\d{3}(?!\d)')
def intcomma(value):
    segments,last_endoffset=[],len(value)
    while last_endoffset &gt; 3:
        digit_group = re_3digits.search(value,0,last_endoffset)
        if not digit_group:
            break
        segments.append(value[digit_group.start():last_endoffset])
        last_endoffset=digit_group.start()
    if not segments:
        return value
    if last_endoffset:
        segments.append(value[:last_endoffset])
    return ','.join(reversed(segments))

def intcomma_recurs(value):
    """"""
    Converts an integer to a string containing commas every three digits.
    For example, 3000 becomes '3,000' and 45000 becomes '45,000'.
    """"""
    new = re.sub(""^(-?\d+)(\d{3})"", '\g&lt;1&gt;,\g&lt;2&gt;', str(value))
    if value == new:
        return new
    else:
        return intcomma(new)

@contextmanager
def timed(save_time_func):
    begin=time.time()
    try:
        yield
    finally:
        save_time_func(time.time()-begin)

def testset_xsimple(func):
    func('5')

def testset_simple(func):
    func('567')

def testset_onecomma(func):
    func('567890')

def testset_complex(func):
    func('-1234567.024')

def testset_average(func):
    func('-1234567.024')
    func('567')
    func('5674')

if __name__ == '__main__':
    print 'Test results:'
    for test_data in ('5','567','1234','1234.56','-253892.045'):
        for func in (intcomma,intcomma_noregex,intcomma_noregex_reversed,intcomma_recurs):
            print func.__name__,test_data,func(test_data)
    times=[]
    def overhead(x):
        pass
    for test_run in xrange(1,4):
        for func in (intcomma,intcomma_noregex,intcomma_noregex_reversed,intcomma_recurs,overhead):
            for testset in (testset_xsimple,testset_simple,testset_onecomma,testset_complex,testset_average):
                for x in xrange(1000): # prime the test
                    testset(func)
                with timed(lambda x:times.append(((test_run,func,testset),x))):
                    for x in xrange(50000):
                        testset(func)
    for (test_run,func,testset),_delta in times:
        print test_run,func.__name__,testset.__name__,_delta
</code></pre>

<p>And here are the test results:</p>

<pre><code>intcomma 5 5
intcomma_noregex 5 5
intcomma_noregex_reversed 5 5
intcomma_recurs 5 5
intcomma 567 567
intcomma_noregex 567 567
intcomma_noregex_reversed 567 567
intcomma_recurs 567 567
intcomma 1234 1,234
intcomma_noregex 1234 1,234
intcomma_noregex_reversed 1234 1,234
intcomma_recurs 1234 1,234
intcomma 1234.56 1,234.56
intcomma_noregex 1234.56 1,234.56
intcomma_noregex_reversed 1234.56 1,234.56
intcomma_recurs 1234.56 1,234.56
intcomma -253892.045 -253,892.045
intcomma_noregex -253892.045 -253,892.045
intcomma_noregex_reversed -253892.045 -253,892.045
intcomma_recurs -253892.045 -253,892.045
1 intcomma testset_xsimple 0.0410001277924
1 intcomma testset_simple 0.0369999408722
1 intcomma testset_onecomma 0.213000059128
1 intcomma testset_complex 0.296000003815
1 intcomma testset_average 0.503000020981
1 intcomma_noregex testset_xsimple 0.134000062943
1 intcomma_noregex testset_simple 0.134999990463
1 intcomma_noregex testset_onecomma 0.190999984741
1 intcomma_noregex testset_complex 0.209000110626
1 intcomma_noregex testset_average 0.513000011444
1 intcomma_noregex_reversed testset_xsimple 0.124000072479
1 intcomma_noregex_reversed testset_simple 0.12700009346
1 intcomma_noregex_reversed testset_onecomma 0.230000019073
1 intcomma_noregex_reversed testset_complex 0.236999988556
1 intcomma_noregex_reversed testset_average 0.56299996376
1 intcomma_recurs testset_xsimple 0.348000049591
1 intcomma_recurs testset_simple 0.34600019455
1 intcomma_recurs testset_onecomma 0.625
1 intcomma_recurs testset_complex 0.773999929428
1 intcomma_recurs testset_average 1.6890001297
1 overhead testset_xsimple 0.0179998874664
1 overhead testset_simple 0.0190000534058
1 overhead testset_onecomma 0.0190000534058
1 overhead testset_complex 0.0190000534058
1 overhead testset_average 0.0309998989105
2 intcomma testset_xsimple 0.0360000133514
2 intcomma testset_simple 0.0369999408722
2 intcomma testset_onecomma 0.207999944687
2 intcomma testset_complex 0.302000045776
2 intcomma testset_average 0.523000001907
2 intcomma_noregex testset_xsimple 0.139999866486
2 intcomma_noregex testset_simple 0.141000032425
2 intcomma_noregex testset_onecomma 0.203999996185
2 intcomma_noregex testset_complex 0.200999975204
2 intcomma_noregex testset_average 0.523000001907
2 intcomma_noregex_reversed testset_xsimple 0.130000114441
2 intcomma_noregex_reversed testset_simple 0.129999876022
2 intcomma_noregex_reversed testset_onecomma 0.236000061035
2 intcomma_noregex_reversed testset_complex 0.241999864578
2 intcomma_noregex_reversed testset_average 0.582999944687
2 intcomma_recurs testset_xsimple 0.351000070572
2 intcomma_recurs testset_simple 0.352999925613
2 intcomma_recurs testset_onecomma 0.648999929428
2 intcomma_recurs testset_complex 0.808000087738
2 intcomma_recurs testset_average 1.81900000572
2 overhead testset_xsimple 0.0189998149872
2 overhead testset_simple 0.0189998149872
2 overhead testset_onecomma 0.0190000534058
2 overhead testset_complex 0.0179998874664
2 overhead testset_average 0.0299999713898
3 intcomma testset_xsimple 0.0360000133514
3 intcomma testset_simple 0.0360000133514
3 intcomma testset_onecomma 0.210000038147
3 intcomma testset_complex 0.305999994278
3 intcomma testset_average 0.493000030518
3 intcomma_noregex testset_xsimple 0.131999969482
3 intcomma_noregex testset_simple 0.136000156403
3 intcomma_noregex testset_onecomma 0.192999839783
3 intcomma_noregex testset_complex 0.202000141144
3 intcomma_noregex testset_average 0.509999990463
3 intcomma_noregex_reversed testset_xsimple 0.125999927521
3 intcomma_noregex_reversed testset_simple 0.126999855042
3 intcomma_noregex_reversed testset_onecomma 0.235999822617
3 intcomma_noregex_reversed testset_complex 0.243000030518
3 intcomma_noregex_reversed testset_average 0.56200003624
3 intcomma_recurs testset_xsimple 0.337000131607
3 intcomma_recurs testset_simple 0.342000007629
3 intcomma_recurs testset_onecomma 0.609999895096
3 intcomma_recurs testset_complex 0.75
3 intcomma_recurs testset_average 1.68300008774
3 overhead testset_xsimple 0.0189998149872
3 overhead testset_simple 0.018000125885
3 overhead testset_onecomma 0.018000125885
3 overhead testset_complex 0.0179998874664
3 overhead testset_average 0.0299999713898
</code></pre>
"
11562205,,1823058.0,5975.0,26,"<p>Here's a one-line regex replacement:</p>

<pre><code>re.sub(""(\d)(?=(\d{3})+(?!\d))"", r""\1,"", ""%d"" % val)
</code></pre>

<p>Works only for inegral outputs:</p>

<pre><code>import re
val = 1234567890
re.sub(""(\d)(?=(\d{3})+(?!\d))"", r""\1,"", ""%d"" % val)
# Returns: '1,234,567,890'

val = 1234567890.1234567890
# Returns: '1,234,567,890'
</code></pre>

<p>Or for floats with less than 4 digits, change the format specifier to <code>%.3f</code>:</p>

<pre><code>re.sub(""(\d)(?=(\d{3})+(?!\d))"", r""\1,"", ""%.3f"" % val)
# Returns: '1,234,567,890.123'
</code></pre>

<p><strong>NB:</strong> Doesn't work correctly with more than three decimal digits as it will attempt to group the decimal part:</p>

<pre><code>re.sub(""(\d)(?=(\d{3})+(?!\d))"", r""\1,"", ""%.5f"" % val)
# Returns: '1,234,567,890.12,346'
</code></pre>

<h1>How it works</h1>

<p>Let's break it down:</p>

<pre><code>re.sub(pattern, repl, string)

pattern = \
    ""(\d)           # Find one digit...
     (?=            # that is followed by...
         (\d{3})+   # one or more groups of three digits...
         (?!\d)     # which are not followed by any more digits.
     )"",

repl = \
    r""\1,"",         # Replace that one digit by itself, followed by a comma,
                    # and continue looking for more matches later in the string.
                    # (re.sub() replaces all matches it finds in the input)

string = \
    ""%d"" % val      # Format the string as a decimal to begin with
</code></pre>
"
12732922,,1823058.0,650654.0,0,"<p>Here is another variant using a generator function that works for integers:</p>

<pre><code>def ncomma(num):
    def _helper(num):
        # assert isinstance(numstr, basestring)
        numstr = '%d' % num
        for ii, digit in enumerate(reversed(numstr)):
            if ii and ii % 3 == 0 and digit.isdigit():
                yield ','
            yield digit

    return ''.join(reversed([n for n in _helper(num)]))
</code></pre>

<p>And here's a test:</p>

<pre><code>&gt;&gt;&gt; for i in (0, 99, 999, 9999, 999999, 1000000, -1, -111, -1111, -111111, -1000000):
...     print i, ncomma(i)
... 
0 0
99 99
999 999
9999 9,999
999999 999,999
1000000 1,000,000
-1 -1
-111 -111
-1111 -1,111
-111111 -111,111
-1000000 -1,000,000
</code></pre>
"
16924278,,1823058.0,131881.0,2,"<p>One liner for Python 2.5+ and Python 3 (positive int only):</p>

<pre><code>''.join(reversed([x + (',' if i and not i % 3 else '') for i, x in enumerate(reversed(str(1234567)))]))
</code></pre>
"
20458213,,1823058.0,2026951.0,1,"<p>This does money along with the commas</p>

<pre><code>def format_money(money, presym='$', postsym=''):
    fmt = '%0.2f' % money
    dot = string.find(fmt, '.')
    ret = []
    if money &lt; 0 :
        ret.append('(')
        p0 = 1
    else :
        p0 = 0
    ret.append(presym)
    p1 = (dot-p0) % 3 + p0
    while True :
        ret.append(fmt[p0:p1])
        if p1 == dot : break
        ret.append(',')
        p0 = p1
        p1 += 3
    ret.append(fmt[dot:])   # decimals
    ret.append(postsym)
    if money &lt; 0 : ret.append(')')
    return ''.join(ret)
</code></pre>
"
32050746,,1823058.0,3420199.0,7,"<p>You can also use <code>'{:n}'.format( value )</code> for a locale representation. I think this is the simpliest way for a locale solution.</p>

<p>For more information, search for <code>thousands</code> in <a href=""https://docs.python.org/3.5/library/string.html#format-specification-mini-language"">Python DOC</a>.</p>

<p>For currency, you can use <code>locale.currency</code>, setting the flag <code>grouping</code>:</p>

<p><strong>Code</strong></p>

<pre><code>import locale

locale.setlocale( locale.LC_ALL, '' )
locale.currency( 1234567.89, grouping = True )
</code></pre>

<p><strong>Output</strong></p>

<pre><code>'Portuguese_Brazil.1252'
'R$ 1.234.567,89'
</code></pre>
"
36262731,,1823058.0,6124322.0,0,"<p>I am a Python beginner, but an experienced programmer. I have Python 3.5, so I can just use the comma, but this is nonetheless an interesting programming exercise. Consider the case of an unsigned integer. The most readable Python program for adding thousands separators appears to be:</p>

<pre><code>def add_commas(instr):
    out = [instr[0]]
    for i in range(1, len(instr)):
        if (len(instr) - i) % 3 == 0:
            out.append(',')
        out.append(instr[i])
    return ''.join(out)
</code></pre>

<p>It is also possible to use a list comprehension:</p>

<pre><code>add_commas(instr):
    rng = reversed(range(1, len(instr) + (len(instr) - 1)//3 + 1))
    out = [',' if j%4 == 0 else instr[-(j - j//4)] for j in rng]
    return ''.join(out)
</code></pre>

<p>This is shorter, and could be a one liner, but you will have to do some mental gymnastics to understand why it works. In both cases we get:</p>

<pre><code>for i in range(1, 11):
    instr = '1234567890'[:i]
    print(instr, add_commas(instr))
</code></pre>



<pre><code>1 1
12 12
123 123
1234 1,234
12345 12,345
123456 123,456
1234567 1,234,567
12345678 12,345,678
123456789 123,456,789
1234567890 1,234,567,890
</code></pre>

<p>The first version is the more sensible choice, if you want the program to be understood.</p>
"
38156617,,1823058.0,6540433.0,3,"<p>from Python version 2.6 you can do this:</p>

<pre><code>def format_builtin(n):
    return format(n, ',')
</code></pre>

<p>For Python versions &lt; 2.6 and just for your information, here are 2 manual solutions, they turn floats to ints but negative numbers work correctly:</p>

<pre><code>def format_number_using_lists(number):
    string = '%d' % number
    result_list = list(string)
    indexes = range(len(string))
    for index in indexes[::-3][1:]:
        if result_list[index] != '-':
            result_list.insert(index+1, ',')
    return ''.join(result_list)
</code></pre>

<p>few things to notice here:</p>

<ul>
<li>this line: <strong>string = '%d' % number</strong> beautifully converts a number to a string, it supports negatives and it drops fractions from floats, making them ints;</li>
<li>this slice <strong>indexes[::-3]</strong> returns each third item starting from
the end, so I used another slice <strong>[1:]</strong> to remove the very last item
cuz I don't need a comma after the last number;</li>
<li>this conditional <strong>if l[index] != '-'</strong> is being used to support negative numbers, do not insert a comma after the minus sign.</li>
</ul>

<p>And a more hardcore version:</p>

<pre><code>def format_number_using_generators_and_list_comprehensions(number):
    string = '%d' % number
    generator = reversed( 
        [
            value+',' if (index!=0 and value!='-' and index%3==0) else value
            for index,value in enumerate(reversed(string))
        ]
    )
    return ''.join(generator)
</code></pre>
"
38553110,,1823058.0,6163621.0,-1,"<p>This is what I do for floats.  Although, honestly, I'm not sure which versions it works for - I'm using 2.7:</p>

<pre><code>my_number = 4385893.382939491

my_string = str(format(int(my_number),"",d"")) + ""."" + str(my_number).rsplit('.')[1][:2]
</code></pre>

<p>Returns: 4,385,893.38</p>

<p>The final [:2] can be changed depending on how many digits after the decimal you want to show.</p>
"
39301723,,1823058.0,2649222.0,-1,"<p>I prefer the locale-based solution for real projects, but here is a simple and effective alternative:</p>

<pre><code>def format_money(f, delimiter=',', frac_digits=2):

    neg = (f &lt; 0)
    if neg:
        f = -f

    s = '%.*f' % (frac_digits, f)
    if len(s) &lt; 5 + frac_digits:
        return ('-' if neg else '') + s

    l = list(s)
    p = len(s) - frac_digits - 5
    l[p::-3] = [i + delimiter for i in l[p::-3]]

    return ('-' if neg else '') + ''.join(l)
</code></pre>
"
3061,Calling a function of a module from a string with the function's name in Python,,121.0,761,"<p>What is the best way to go about calling a function given a string with the function's name in a Python program.  For example, let's say that I have a module <code>foo</code>, and I have a string whose contents are <code>""bar""</code>. What is the best way to go about calling <code>foo.bar()</code>?</p>

<p>I need to get the return value of the function, which is why I don't just use <code>eval</code>. I figured out how to do it by using <code>eval</code> to define a temp function that returns the result of that function call, but I'm hoping that there is a more elegant way to do this.</p>
"
3071,,3061.0,363.0,925,"<p>Assuming module <code>foo</code> with method <code>bar</code>:</p>

<pre><code>import foo
methodToCall = getattr(foo, 'bar')
result = methodToCall()
</code></pre>

<p>As far as that goes, lines 2 and 3 can be compressed to:</p>

<pre><code>result = getattr(foo, 'bar')()
</code></pre>

<p>if that makes more sense for your use case.  You can use <code>getattr</code> in this fashion on class instance bound methods, module-level methods, class methods... the list goes on.</p>
"
4605,,3061.0,618.0,145,"<p>Patrick's solution is probably the cleanest.
If you need to dynamically pick up the module as well, you can import it like:</p>

<pre><code>m = __import__ ('foo')
func = getattr(m,'bar')
func()
</code></pre>
"
834451,,3061.0,25450.0,266,"<pre><code>locals()[""myfunction""]()
</code></pre>

<p>or</p>

<pre><code>globals()[""myfunction""]()
</code></pre>

<p><a href=""http://docs.python.org/library/functions.html#locals"">locals</a> returns a dictionary with a current local symbol table. <a href=""http://docs.python.org/library/functions.html#globals"">globals</a> returns a dictionary with global symbol table.</p>
"
9272378,,3061.0,1060339.0,12,"<p>For what it's worth, if you needed to pass the function (or class) name and app name as a string, then you could do this:</p>

<pre><code>myFnName  = ""MyFn""
myAppName = ""MyApp""
app = sys.modules[myAppName]
fn  = getattr(app,myFnName)
</code></pre>
"
12025554,,3061.0,1609832.0,46,"<p>Just a simple contribution. If the class that we need to instance is in the same file, we can use something like this:</p>

<pre><code># Get class from globals and create an instance
m = globals()['our_class']()

# Get the function (from the instance) that we need to call
func = getattr(m, 'function_name')

# Call it
func()
</code></pre>

<p>For example:</p>

<pre><code>class A:
    def __init__(self):
        pass

    def sampleFunc(self, arg):
        print('you called sampleFunc({})'.format(arg))

m = globals()['A']()
func = getattr(m, 'sampleFunc')
func('sample arg')

# Sample, all on one line
getattr(globals()['A'](), 'sampleFunc')('sample arg')
</code></pre>

<p>And, if not a class:</p>

<pre><code>def sampleFunc(arg):
    print('you called sampleFunc({})'.format(arg))

globals()['sampleFunc']('sample arg')
</code></pre>
"
14072943,,3061.0,1112523.0,8,"<p>none of what was suggested helped me. I did discover this though.</p>

<pre><code>&lt;object&gt;.__getattribute__(&lt;string name&gt;)(&lt;params&gt;)
</code></pre>

<p>I am using python 2.66 </p>

<p>Hope this helps</p>
"
19393328,,3061.0,272238.0,39,"<p>Given a string, with a complete python path to a function, this is how I went about getting the result of said function:</p>

<pre><code>import importlib
function_string = 'mypackage.mymodule.myfunc'
mod_name, func_name = function_string.rsplit('.',1)
mod = importlib.import_module(mod_name)
func = getattr(mod, func_name)
result = func()
</code></pre>
"
22959509,,3061.0,1356953.0,17,"<p>The answer (I hope) no one ever wanted</p>

<p>Eval like behavior</p>

<pre><code>getattr(locals().get(""foo"") or globals().get(""foo""), ""bar"")()
</code></pre>

<p>Why not add auto-importing</p>

<pre><code>getattr(
    locals().get(""foo"") or 
    globals().get(""foo"") or
    __import__(""foo""), 
""bar"")()
</code></pre>

<p>In case we have extra dictionaries we want to check</p>

<pre><code>getattr(next((x for x in (f(""foo"") for f in 
                          [locals().get, globals().get, 
                           self.__dict__.get, __import__]) 
              if x)),
""bar"")()
</code></pre>

<p>We need to go deeper</p>

<pre><code>getattr(next((x for x in (f(""foo"") for f in 
              ([locals().get, globals().get, self.__dict__.get] +
               [d.get for d in (list(dd.values()) for dd in 
                                [locals(),globals(),self.__dict__]
                                if isinstance(dd,dict))
                if isinstance(d,dict)] + 
               [__import__])) 
        if x)),
""bar"")()
</code></pre>
"
94935,What is the difference between range and xrange functions in Python 2.X?,,1384652.0,378,"<p>Apparently xrange is faster but I have no idea why it's faster (and no proof besides the anecdotal so far that it is faster) or what besides that is different about</p>

<pre><code>for i in range(0, 20):
for i in xrange(0, 20):
</code></pre>
"
94953,,94935.0,9402.0,0,"<p>See this <a href=""http://avinashv.net/2008/05/pythons-range-and-xrange/"" rel=""nofollow"">post</a> to find difference between range and xrange:</p>

<p>To quote:</p>

<blockquote>
  <p><code>range</code> returns exactly what you think: a list of consecutive
  integers, of a defined length beginning with 0. <code>xrange</code>, however,
  returns an <em>""xrange object""</em>, which acts a great deal like an iterator</p>
</blockquote>
"
94957,,94935.0,4482.0,25,"<p>xrange returns an iterator and only keeps one number in memory at a time.  range keeps the entire list of numbers in memory.</p>
"
94962,,94935.0,18031.0,460,"<p>range creates a list, so if you do <code>range(1, 10000000)</code> it creates a list in memory with <code>9999999</code> elements.</p>

<p><code>xrange</code> is a sequence object that  evaluates lazily.  </p>
"
94965,,94935.0,9323.0,2,"<p>range generates the entire list and returns it.  xrange does not -- it generates the numbers in the list on demand.</p>
"
94966,,94935.0,17457.0,2,"<p>xrange uses an iterator (generates values on the fly), range returns a list.</p>
"
94971,,94935.0,8570.0,18,"<p>Do spend some time with the <a href=""http://docs.python.org/lib/typesseq-xrange.html"">Library Reference</a>. The more familiar you are with it, the faster you can find answers to questions like this. Especially important are the first few chapters about builtin objects and types.</p>

<blockquote>
  <p>The advantage of the xrange type is that an xrange object will always 
  take the same amount of memory, no matter the size of the range it represents. 
  There are no consistent performance advantages.</p>
</blockquote>

<p>Another way to find quick information about a Python construct is the docstring and the help-function:</p>

<pre><code>print xrange.__doc__ # def doc(x): print x.__doc__ is super useful
help(xrange)
</code></pre>
"
95010,,94935.0,14260.0,8,"<p>It is for optimization reasons.</p>

<p>range() will create a list of values from start to end (0 .. 20 in your example). This will become an expensive operation on very large ranges.</p>

<p>xrange() on the other hand is much more optimised. it will only compute the next value when needed (via an xrange sequence object) and does not create a list of all values like range() does.</p>
"
95100,,94935.0,1595.0,148,"<blockquote>
  <p>range creates a list, so if you do <code>range(1, 10000000)</code> it creates a list in memory with <code>10000000</code> elements.</p>
  
  <p><code>xrange</code> <s>is a generator, so it</s> is a sequence object <s>is a</s> that  evaluates lazily.  </p>
</blockquote>

<p>This is true, but in Python 3, range will be implemented by the Python 2 xrange(). If you need to actually generate the list, you will need to do:</p>

<pre><code>list(range(1,100))
</code></pre>
"
95168,,94935.0,12320.0,51,"<p><code>xrange</code> only stores the range params and generates the numbers on demand. However the C implementation of Python currently restricts its args to C longs:</p>

<pre><code>xrange(2**32-1, 2**32+1)  # When long is 32 bits, OverflowError: Python int too large to convert to C long
range(2**32-1, 2**32+1)   # OK --&gt; [4294967295L, 4294967296L]
</code></pre>

<p>Note that in Python 3.0 there is only <code>range</code> and it behaves like the 2.x <code>xrange</code> but without the limitations on minimum and maximum end points.</p>
"
95549,,94935.0,7363.0,10,"<blockquote>
  <p>range creates a list, so if you do range(1, 10000000) it creates a list in memory with 10000000 elements.
  xrange is a generator, so it evaluates lazily.</p>
</blockquote>

<p>This brings you two advantages:</p>

<ol>
<li>You can iterate longer lists without getting a <code>MemoryError</code>.</li>
<li>As it resolves each number lazily, if you stop iteration early, you won't waste time creating the whole list.</li>
</ol>
"
97530,,94935.0,15154.0,77,"<p>Remember, use the timeit module to test which of small snipps of code is faster!</p>

<pre><code>$ python -m timeit 'for i in range(1000000):' ' pass'
10 loops, best of 3: 90.5 msec per loop
$ python -m timeit 'for i in xrange(1000000):' ' pass'
10 loops, best of 3: 51.1 msec per loop
</code></pre>

<p>Personally, I always use range(), unless I were dealing with <em>really</em> huge lists -- as you can see, time-wise, for a list of a million entries, the extra overhead is only 0.04 seconds.  And as Corey points out, in Python 3.0 xrange will go away and range will give you nice iterator behaviour anyway.</p>
"
5351725,,94935.0,123033.0,2,"<p>When testing range against xrange in a loop (I know I should use <a href=""http://docs.python.org/library/timeit.html"" rel=""nofollow"">timeit</a>, but this was swiftly hacked up from memory using a simple list comprehension example) I found the following:</p>

<pre><code>import time

for x in range(1, 10):

    t = time.time()
    [v*10 for v in range(1, 10000)]
    print ""range:  %.4f"" % ((time.time()-t)*100)

    t = time.time()
    [v*10 for v in xrange(1, 10000)]
    print ""xrange: %.4f"" % ((time.time()-t)*100)
</code></pre>

<p>which gives:</p>

<pre><code>$python range_tests.py
range:  0.4273
xrange: 0.3733
range:  0.3881
xrange: 0.3507
range:  0.3712
xrange: 0.3565
range:  0.4031
xrange: 0.3558
range:  0.3714
xrange: 0.3520
range:  0.3834
xrange: 0.3546
range:  0.3717
xrange: 0.3511
range:  0.3745
xrange: 0.3523
range:  0.3858
xrange: 0.3997 &lt;- garbage collection?
</code></pre>

<p>Or, using xrange in the for loop:</p>

<pre><code>range:  0.4172
xrange: 0.3701
range:  0.3840
xrange: 0.3547
range:  0.3830
xrange: 0.3862 &lt;- garbage collection?
range:  0.4019
xrange: 0.3532
range:  0.3738
xrange: 0.3726
range:  0.3762
xrange: 0.3533
range:  0.3710
xrange: 0.3509
range:  0.3738
xrange: 0.3512
range:  0.3703
xrange: 0.3509
</code></pre>

<p>Is my snippet testing properly? Any comments on the slower instance of xrange? Or a better example :-)</p>
"
21137807,,94935.0,3198177.0,1,"<p>On a requirement for scanning/printing of 0-N items , range and xrange works as follows.</p>

<p>range() - creates a new list in the memory and takes the whole 0 to N items(totally N+1) and prints them.
xrange() - creates a iterator instance that scans through the items and keeps only the current encountered item into the memory , hence utilising same amount of memory all the time.</p>

<p>In case the required element is somewhat at the beginning of the list only then it saves a good amount of time and memory.</p>
"
22905006,,94935.0,1936024.0,4,"<p>I am shocked nobody read <a href=""https://docs.python.org/2/library/functions.html#xrange"" rel=""nofollow"">doc</a></p>

<p>This function is very similar to range(), but returns an xrange object instead of a list. This is an opaque sequence type which yields the same values as the corresponding list, without actually storing them all simultaneously. The advantage of xrange() over range() is minimal (since xrange() still has to create the values when asked for them) except when a very large range is used on a memory-starved machine or when all of the rangeâs elements are never used (such as when the loop is usually terminated with break).</p>
"
27144195,,94935.0,2956066.0,2,"<p>What?<br>
<code>range</code> returns a static list at runtime.<br>
<code>xrange</code> returns an <code>object</code> (which acts like a generator, although it's certainly not one) from which values are generated as and when required.</p>

<p>When to use which?  </p>

<ul>
<li>Use <code>xrange</code> if you want to generate a list for a gigantic range, say 1 billion, especially when you have a ""memory sensitive system"" like a cell phone.</li>
<li>Use <code>range</code> if you want to iterate over the list several times.</li>
</ul>

<p>PS: Python 3.x's <code>range</code> function == Python 2.x's <code>xrange</code> function.</p>
"
27752378,,94935.0,3935256.0,0,"<p><strong>Range</strong> returns a <strong>list</strong> while <strong>xrange</strong> returns an <strong>xrange</strong> object which takes the same memory irrespective of the range size,as in this case,only one element is generated and available per iteration whereas in case of using range, all the elements are generated at once and are available in the memory.</p>
"
30088340,,94935.0,908494.0,3,"<p>Some of the other answers mention that Python 3 eliminated 2.x's <code>range</code> and renamed 2.x's <code>xrange</code> to <code>range</code>. However, unless you're using 3.0 or 3.1 (which nobody should be), it's actually a somewhat different type.</p>

<p>As <a href=""https://docs.python.org/3.1/library/stdtypes.html#range-type"" rel=""nofollow"">the 3.1 docs</a> say:</p>

<blockquote>
  <p>Range objects have very little behavior: they only support indexing, iteration, and the <code>len</code> function.</p>
</blockquote>

<p>However, in 3.2+, <code>range</code> is a full sequenceâit supports extended slices, and all of the methods of <a href=""https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes"" rel=""nofollow""><code>collections.abc.Sequence</code></a> with the same semantics as a <code>list</code>.<sup>*</sup></p>

<p>And, at least in CPython and PyPy (the only two 3.2+ implementations that currently exist), it also has constant-time implementations of the <code>index</code> and <code>count</code> methods and the <code>in</code> operator (as long as you only pass it integers). This means writing <code>123456 in r</code> is reasonable in 3.2+, while in 2.7 or 3.1 it would be a horrible idea.</p>

<hr>

<p><sub>* The fact that <code>issubclass(xrange, collections.Sequence)</code> returns <code>True</code> in 2.6-2.7 and 3.0-3.1 is <a href=""http://bugs.python.org/issue9213"" rel=""nofollow"">a bug</a> that was fixed in 3.2 and not backported.</sub></p>
"
30545536,,94935.0,1143274.0,1,"<p>The difference decreases for smaller arguments to <code>range(..)</code> / <code>xrange(..)</code>:</p>

<pre><code>$ python -m timeit ""for i in xrange(10111):"" "" for k in range(100):"" ""  pass""
10 loops, best of 3: 59.4 msec per loop

$ python -m timeit ""for i in xrange(10111):"" "" for k in xrange(100):"" ""  pass""
10 loops, best of 3: 46.9 msec per loop
</code></pre>

<p>In this case <code>xrange(100)</code> is only about 20% more efficient.</p>
"
30997385,,94935.0,2013238.0,6,"<p><strong>range():</strong> range(1, 10) returns a list from 1 to 10 numbers &amp; hold whole list in memory.</p>

<p><strong>xrange():</strong> Like range(), but instead of returning a list, returns an object that generates the numbers in the range on demand. For looping, this is lightly faster than range() and more memory efficient.
 xrange() object like an iterator and generates the numbers on demand.(Lazy Evaluation)</p>

<pre><code>In [1]: range(1,10)

Out[1]: [1, 2, 3, 4, 5, 6, 7, 8, 9]

In [2]: xrange(10)

Out[2]: xrange(10)

In [3]: print xrange.__doc__

xrange([start,] stop[, step]) -&gt; xrange object
</code></pre>
"
31761387,,94935.0,4344438.0,2,"<p>Read the following post for the comparison between range and xrange with graphical analysis.</p>

<p><a href=""http://justindailey.blogspot.in/2011/09/python-range-vs-xrange.html"" rel=""nofollow"">Python range Vs xrange</a></p>
"
34877258,,94935.0,5808816.0,4,"<p>xrange() and range() in python works similarly as for the user , but the difference comes when we are talking about how the memory is allocated in using both the function.</p>

<p>When we are using range() we allocate memory for all the variables it is generating, so it is not recommended to use with larger no. of variables to be generated.</p>

<p>xrange() on the other hand generate only a particular value at a time and can only be used with the for loop to print all the values required.</p>
"
35680931,,94935.0,5326634.0,3,"<p>In python 2.x</p>

<p><strong>range(x)</strong> returns a list, that is created in memory with x elements.</p>

<pre><code>&gt;&gt;&gt; a = range(5)
&gt;&gt;&gt; a
[0, 1, 2, 3, 4]
</code></pre>

<p><strong>xrange(x)</strong> returns an xrange object which is a generator obj which generates the numbers on demand. they are computed during for-loop(Lazy Evaluation).</p>

<p>For looping, this is slightly faster than range() and more memory efficient.</p>

<pre><code>&gt;&gt;&gt; b = xrange(5)
&gt;&gt;&gt; b
xrange(5)
</code></pre>
"
38318039,,94935.0,6491545.0,4,"<p><code>range(x,y)</code> returns a list of each number in between x and y if you use a <code>for</code> loop, then <code>range</code> is slower. In fact, <code>range</code> has a bigger Index range. <code>range(x.y)</code> will print out a list of all the numbers in between x and y</p>

<p><code>xrange(x,y)</code> returns <code>xrange(x,y)</code> but if you used a <code>for</code> loop, then <code>xrange</code> is faster. <code>xrange</code> has a smaller Index range. <code>xrange</code> will not only print out <code>xrange(x,y)</code> but it will still keep all the numbers that are in it.</p>

<pre><code>[In] range(1,10)
[Out] [1, 2, 3, 4, 5, 6, 7, 8, 9]
[In] xrange(1,10)
[Out] xrange(1,10)
</code></pre>

<p>If you use a <code>for</code> loop, then it would work</p>

<pre><code>[In] for i in range(1,10):
        print i
[Out] 1
      2
      3
      4
      5
      6
      7
      8
      9
[In] for i in xrange(1,10):
         print i
[Out] 1
      2
      3
      4
      5
      6
      7
      8
      9
</code></pre>
"
231767,"What does the ""yield"" keyword do?",,18300.0,5524,"<p>What is the use of the <code>yield</code> keyword in Python? What does it do?</p>

<p>For example, I'm trying to understand this code<sup><strong>1</strong></sup>:</p>

<pre><code>def _get_child_candidates(self, distance, min_dist, max_dist):
    if self._leftchild and distance - max_dist &lt; self._median:
        yield self._leftchild
    if self._rightchild and distance + max_dist &gt;= self._median:
        yield self._rightchild  
</code></pre>

<p>And this is the caller:</p>

<pre><code>result, candidates = list(), [self]
while candidates:
    node = candidates.pop()
    distance = node._get_dist(obj)
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))
return result
</code></pre>

<p>What happens when the method <code>_get_child_candidates</code> is called?
A list is returned? A single element is returned? Is it called again? When will subsequent calls stop?</p>

<hr>

<p><sub>
1. The code comes from Jochen Schulz (jrschulz), who made a great Python library for metric spaces. This is the link to the complete source: <a href=""http://well-adjusted.de/~jrschulz/mspace/"">Module mspace</a>.</sub></p>
"
231778,,231767.0,8458.0,141,"<p><code>yield</code> is just like <code>return</code> - it returns whatever you tell it to.  The only difference is that the next time you call the function, execution starts from the last call to the <code>yield</code> statement.</p>

<p>In the case of your code, the function <code>get_child_candidates</code> is acting like an iterator so that when you extend your list, it adds one element at a time to the new list.</p>

<p><code>list.extend</code> calls an iterator until it's exhausted.  In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list.</p>
"
231788,,231767.0,22656.0,78,"<p>It's returning a generator. I'm not particularly familiar with Python, but I believe it's the same kind of thing as <a href=""http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx"">C#'s iterator blocks</a> if you're familiar with those.</p>

<p>There's an <a href=""http://www.ibm.com/developerworks/library/l-pycon.html"">IBM article</a> which explains it reasonably well (for Python) as far as I can see.</p>

<p>The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - <em>as if the generator method was paused</em>. Now obviously you can't really ""pause"" a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like. This is much easier than writing an iterator yourself.</p>
"
231801,,231767.0,2147.0,236,"<p>Think of it this way:</p>

<p>An iterator is just a fancy sounding term for an object that has a next() method.  So a yield-ed function ends up being something like this:</p>

<p>Original version:</p>

<pre><code>def some_function():
    for i in xrange(4):
        yield i

for i in some_function():
    print i
</code></pre>

<p>This is basically what the python interpreter does with the above code:</p>

<pre><code>class it:
    def __init__(self):
        #start at -1 so that we get 0 when we add 1 below.
        self.count = -1
    #the __iter__ method will be called once by the for loop.
    #the rest of the magic happens on the object returned by this method.
    #in this case it is the object itself.
    def __iter__(self):
        return self
    #the next method will be called repeatedly by the for loop
    #until it raises StopIteration.
    def next(self):
        self.count += 1
        if self.count &lt; 4:
            return self.count
        else:
            #a StopIteration exception is raised
            #to signal that the iterator is done.
            #This is caught implicitly by the for loop.
            raise StopIteration 

def some_func():
    return it()

for i in some_func():
    print i
</code></pre>

<p>For more insight as to what's happening behind the scenes, the for loop can be rewritten to this:</p>

<pre><code>iterator = some_func()
try:
    while 1:
        print iterator.next()
except StopIteration:
    pass
</code></pre>

<p>Does that make more sense or just confuse you more?  :)</p>

<p><strong>EDIT:</strong> I should note that this IS an oversimplification for illustrative purposes.  :)</p>

<p><strong>EDIT 2:</strong> Forgot to throw the StopIteration exception</p>
"
231855,,231767.0,9951.0,8384,"<p>To understand what <code>yield</code> does, you must understand what <em>generators</em> are. And before generators come <em>iterables</em>.</p>

<h2>Iterables</h2>

<p>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</p>

<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]
&gt;&gt;&gt; for i in mylist:
...    print(i)
1
2
3
</code></pre>

<p><code>mylist</code> is an <em>iterable</em>. When you use a list comprehension, you create a list, and so an iterable:</p>

<pre><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]
&gt;&gt;&gt; for i in mylist:
...    print(i)
0
1
4
</code></pre>

<p>Everything you can use ""<code>for... in...</code>"" on is an iterable; <code>lists</code>, <code>strings</code>, files...</p>

<p>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</p>

<h2>Generators</h2>

<p>Generators are iterators, but <strong>you can only iterate over them once</strong>. It's because they do not store all the values in memory, <strong>they generate the values on the fly</strong>:</p>

<pre><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))
&gt;&gt;&gt; for i in mygenerator:
...    print(i)
0
1
4
</code></pre>

<p>It is just the same except you used <code>()</code> instead of <code>[]</code>. BUT, you <strong>cannot</strong> perform <code>for i in mygenerator</code> a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one.</p>

<h2>Yield</h2>

<p><code>Yield</code> is a keyword that is used like <code>return</code>, except the function will return a generator.</p>

<pre><code>&gt;&gt;&gt; def createGenerator():
...    mylist = range(3)
...    for i in mylist:
...        yield i*i
...
&gt;&gt;&gt; mygenerator = createGenerator() # create a generator
&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!
&lt;generator object createGenerator at 0xb7555c34&gt;
&gt;&gt;&gt; for i in mygenerator:
...     print(i)
0
1
4
</code></pre>

<p>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</p>

<p>To master <code>yield</code>, you must understand that <strong>when you call the function, the code you have written in the function body does not run.</strong> The function only returns the generator object, this is a bit tricky :-)</p>

<p>Then, your code will be run each time the <code>for</code> uses the generator.</p>

<p>Now the hard part:</p>

<p>The first time the <code>for</code> calls the generator object created from your function, it will run the code in your function from the beginning until it hits <code>yield</code>, then it'll return the first value of the loop. Then, each other call will run the loop you have written in the function one more time, and return the next value, until there is no value to return.</p>

<p>The generator is considered empty once the function runs but does not hit <code>yield</code> anymore. It can be because the loop had come to an end, or because you do not satisfy an <code>""if/else""</code> anymore.</p>

<hr>

<h2>Your code explained</h2>

<p>Generator:</p>

<pre><code># Here you create the method of the node object that will return the generator
def node._get_child_candidates(self, distance, min_dist, max_dist):

  # Here is the code that will be called each time you use the generator object:

  # If there is still a child of the node object on its left
  # AND if distance is ok, return the next child
  if self._leftchild and distance - max_dist &lt; self._median:
      yield self._leftchild

  # If there is still a child of the node object on its right
  # AND if distance is ok, return the next child
  if self._rightchild and distance + max_dist &gt;= self._median:
      yield self._rightchild

  # If the function arrives here, the generator will be considered empty
  # there is no more than two values: the left and the right children
</code></pre>

<p>Caller:</p>

<pre><code># Create an empty list and a list with the current object reference
result, candidates = list(), [self]

# Loop on candidates (they contain only one element at the beginning)
while candidates:

    # Get the last candidate and remove it from the list
    node = candidates.pop()

    # Get the distance between obj and the candidate
    distance = node._get_dist(obj)

    # If distance is ok, then you can fill the result
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)

    # Add the children of the candidate in the candidates list
    # so the loop will keep running until it will have looked
    # at all the children of the children of the children, etc. of the candidate
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))

return result
</code></pre>

<p>This code contains several smart parts:</p>

<ul>
<li><p>The loop iterates on a list but the list expands while the loop is being iterated :-) It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code> exhausts all the values of the generator, but <code>while</code> keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</p></li>
<li><p>The <code>extend()</code> method is a list object method that expects an iterable and adds its values to the list.</p></li>
</ul>

<p>Usually we pass a list to it:</p>

<pre><code>&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; b = [3, 4]
&gt;&gt;&gt; a.extend(b)
&gt;&gt;&gt; print(a)
[1, 2, 3, 4]
</code></pre>

<p>But in your code it gets a generator, which is good because:</p>

<ol>
<li>You don't need to read the values twice.</li>
<li>You may have a lot of children and you don't want them all stored in memory.</li>
</ol>

<p>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples and generators! This is called duck typing and is one of the reason why Python is so cool. But this is another story, for another question...</p>

<p>You can stop here, or read a little bit to see an advanced use of a generator:</p>

<h2>Controlling a generator exhaustion</h2>

<pre><code>&gt;&gt;&gt; class Bank(): # let's create a bank, building ATMs
...    crisis = False
...    def create_atm(self):
...        while not self.crisis:
...            yield ""$100""
&gt;&gt;&gt; hsbc = Bank() # when everything's ok the ATM gives you as much as you want
&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()
&gt;&gt;&gt; print(corner_street_atm.next())
$100
&gt;&gt;&gt; print(corner_street_atm.next())
$100
&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])
['$100', '$100', '$100', '$100', '$100']
&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money!
&gt;&gt;&gt; print(corner_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # it's even true for new ATMs
&gt;&gt;&gt; print(wall_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty
&gt;&gt;&gt; print(corner_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # build a new one to get back in business
&gt;&gt;&gt; for cash in brand_new_atm:
...    print cash
$100
$100
$100
$100
$100
$100
$100
$100
$100
...
</code></pre>

<p>It can be useful for various things like controlling access to a resource.</p>

<h2>Itertools, your best friend</h2>

<p>The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?
Chain two generators? Group values in a nested list with a one liner? <code>Map / Zip</code> without creating another list?</p>

<p>Then just <code>import itertools</code>.</p>

<p>An example? Let's see the possible orders of arrival for a 4 horse race:</p>

<pre><code>&gt;&gt;&gt; horses = [1, 2, 3, 4]
&gt;&gt;&gt; races = itertools.permutations(horses)
&gt;&gt;&gt; print(races)
&lt;itertools.permutations object at 0xb754f1dc&gt;
&gt;&gt;&gt; print(list(itertools.permutations(horses)))
[(1, 2, 3, 4),
 (1, 2, 4, 3),
 (1, 3, 2, 4),
 (1, 3, 4, 2),
 (1, 4, 2, 3),
 (1, 4, 3, 2),
 (2, 1, 3, 4),
 (2, 1, 4, 3),
 (2, 3, 1, 4),
 (2, 3, 4, 1),
 (2, 4, 1, 3),
 (2, 4, 3, 1),
 (3, 1, 2, 4),
 (3, 1, 4, 2),
 (3, 2, 1, 4),
 (3, 2, 4, 1),
 (3, 4, 1, 2),
 (3, 4, 2, 1),
 (4, 1, 2, 3),
 (4, 1, 3, 2),
 (4, 2, 1, 3),
 (4, 2, 3, 1),
 (4, 3, 1, 2),
 (4, 3, 2, 1)]
</code></pre>

<h2>Understanding the inner mechanisms of iteration</h2>

<p>Iteration is a process implying iterables (implementing the <code>__iter__()</code> method) and iterators (implementing the <code>__next__()</code> method).
Iterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</p>

<p>More about it in this article about <a href=""http://effbot.org/zone/python-for-statement.htm"">how does the for loop work</a>.</p>
"
232111,,231767.0,6899.0,72,"<p>An example in plain language. I will provide a correspondence between high-level human concepts to low-level python concepts.</p>

<p>I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following:</p>

<ul>
<li>I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is.<br />
<b>This step corresponds to <code>def</code>ining the generator function, i.e. the function containing a <code>yield</code>.</b></li>
<li>Sometime later, I tell you, ""ok, get ready to tell me the sequence of numbers"".<br />
<b>This step corresponds to calling the generator function which returns a generator object.</b> Note that you don't tell me any numbers yet, you just grab your paper and pencil.</li>
<li>I ask you, ""tell me the next number"", and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, what is the next number. I don't care about the details.<br />
<b>This step corresponds to calling <code>.next()</code> on the generator object.</b></li>
<li>â¦ repeat previous step, untilâ¦</li>
<li>eventually, you might come to an end. You don't tell me a number, you just shout, ""hold your horses! I'm done! No more numbers!""<br />
<b>This step corresponds to the generator object ending its job, and raising a <code>StopIteration</code> exception</b> The generator function does not need to raise the exception, it's raised automatically when the function ends or issues a <code>return</code>.</li>
</ul>

<p>This is what a generator does (a function that contains a <code>yield</code>); it starts executing, pauses whenever it does a <code>yield</code>, and when asked for a <code>.next()</code> value it continues from the point it was last. It fits perfectly by design with the iterator protocol of python, which describes how to sequentially request for values.</p>

<p>The most famous user of the iterator protocol is the <code>for</code> command in python. So, whenever you do a:</p>

<pre><code>for item in sequence:
</code></pre>

<p>it doesn't matter if <code>sequence</code> is a list, a string, a dictionary or a generator <em>object</em> like described above; the result is the same: you read items off a sequence one by one.</p>

<p>Note that <code>def</code>ining a function which contains a <code>yield</code> keyword is not the only way to create a generator; it's just the easiest way to create one.</p>

<p>For more accurate information, read about <a href=""http://docs.python.org/library/stdtypes.html#iterator-types"">iterator types</a>, the <a href=""http://docs.python.org/reference/simple_stmts.html#yield"">yield statement</a> and <a href=""http://docs.python.org/glossary.html#term-generator"">generators</a> in the Python documentation.</p>
"
232791,,231767.0,19403.0,160,"<p>I feel like I post a link to this presentation every day:  David M. Beazly's <a href=""http://www.dabeaz.com/generators/"">Generator Tricks for Systems Programmers</a>.  If you're a Python programmer and you're not extremely familiar with generators, you should read this.  It's a very clear explanation of what generators are, how they work, what the yield statement does, and it answers the question ""Do you really want to mess around with this obscure language feature?""  </p>

<p>SPOILER ALERT.  The answer is:  Yes.  Yes, you do.</p>
"
232853,,231767.0,15055.0,121,"<p>There's one extra thing to mention: a function that yields doesn't actually have to terminate. I've written code like this:</p>

<pre><code>def fib():
    last, cur = 0, 1
    while True: 
        yield cur
        last, cur = cur, last + cur
</code></pre>

<p>Then I can use it in other code like this:</p>

<pre><code>for f in fib():
    if some_condition: break
    coolfuncs(f);
</code></pre>

<p>It really helps simplify some problems, and makes some things easier to work with. </p>
"
237028,,231767.0,28409.0,1095,"<h2>Shortcut to <a href=""http://en.wikipedia.org/wiki/Grok"">Grokking</a> <code>yield</code></h2>

<p>When you see a function with <code>yield</code> statements, apply this easy trick to understand what will happen:</p>

<ol>
<li>Insert a line <code>result = []</code> at the start of the function.</li>
<li>Replace each <code>yield expr</code> with <code>result.append(expr)</code>.</li>
<li>Insert a line <code>return result</code> at the bottom of the function.</li>
<li>Yay - no more <code>yield</code> statements! Read and figure out code.</li>
<li>Compare function to original definition.</li>
</ol>

<p>This trick may give you an idea of the logic behind the function, but what actually happens with <code>yield</code> is significantly different that what happens in the list based approach. In many cases the yield approach will be a lot more memory efficient and faster too. In other cases this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...</p>

<h2>Don't confuse your Iterables, Iterators and Generators</h2>

<p>First, the <strong>iterator protocol</strong> - when you write</p>

<pre><code>for x in mylist:
    ...loop body...
</code></pre>

<p>Python performs the following two steps:</p>

<ol>
<li><p>Gets an iterator for <code>mylist</code>:</p>

<p>Call <code>iter(mylist)</code> -> this returns an object with a <code>next()</code> method (or <code>__next__()</code> in Python 3).</p>

<p>[This is the step most people forget to tell you about]</p></li>
<li><p>Uses the iterator to loop over items:</p>

<p>Keep calling the <code>next()</code> method on the iterator returned from step 1. The return value from <code>next()</code> is assigned to <code>x</code> and the loop body is executed. If an exception <code>StopIteration</code> is raised from within <code>next()</code>, it means there are no more values in the iterator and the loop is exited.</p></li>
</ol>

<p>The truth is Python performs the above two steps anytime it wants to <em>loop over</em> the contents of an object - so it could be a for loop, but it could also be code like <code>otherlist.extend(mylist)</code> (where <code>otherlist</code> is a Python list).</p>

<p>Here <code>mylist</code> is an <em>iterable</em> because it implements the iterator protocol. In a user defined class, you can implement the <code>__iter__()</code> method to make instances of your class iterable. This method should return an <em>iterator</em>. An iterator is an object with a <code>next()</code> method. It is possible to implement both <code>__iter__()</code> and <code>next()</code> on the same class, and have <code>__iter__()</code> return <code>self</code>. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.</p>

<p>So that's the iterator protocol, many objects implement this protocol:</p>

<ol>
<li>Built-in lists, dictionaries, tuples, sets, files.</li>
<li>User defined classes that implement <code>__iter__()</code>.</li>
<li>Generators.</li>
</ol>

<p>Note that a <code>for</code> loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls <code>next()</code>. Built-in lists return their items one by one, dictionaries return the <em>keys</em> one by one, files return the <em>lines</em> one by one, etc. And generators return... well that's where <code>yield</code> comes in:</p>

<pre><code>def f123():
    yield 1
    yield 2
    yield 3

for item in f123():
    print item
</code></pre>

<p>Instead of <code>yield</code> statements, if you had three <code>return</code> statements in <code>f123()</code> only the first would get executed, and the function would exit. But <code>f123()</code> is no ordinary function. When <code>f123()</code> is called, it <em>does not</em> return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the <code>for</code> loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the <code>yield</code> it previously returned from, executes the next line of code, in this case a <code>yield</code> statement, and returns that as the next item. This happens until the function exits, at which point the generator raises <code>StopIteration</code>, and the loop exits. </p>

<p>So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing <code>__iter__()</code> and <code>next()</code> methods to keep the <code>for</code> loop happy. At the other end however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode.</p>

<h2>Why Use Generators?</h2>

<p>Usually you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class <code>SomethingIter</code> that keeps state in instance members and performs the next logical step in it's <code>next()</code> (or <code>__next__()</code> in Python 3) method. Depending on the logic, the code inside the <code>next()</code> method may end up looking very complex and be prone to bugs. Here generators provide a clean and easy solution.</p>
"
6400990,,231767.0,711085.0,215,"<p>The <code>yield</code> keyword is reduced to two simple facts:</p>

<ol>
<li>If the compiler detects the <code>yield</code> keyword <em>anywhere</em> inside a function, that function no longer returns via the <code>return</code> statement. <strong><em>Instead</em></strong>, it <strong>immediately</strong> returns a <strong>lazy ""pending list"" object</strong> called a generator</li>
<li>A generator is iterable. What is an <em>iterable</em>? It's anything like a <code>list</code> or <code>set</code> or <code>range</code> or dict-view, with a <em>built-in protocol for visiting each element in a certain order</em>.</li>
</ol>

<p>In a nutshell: <strong>a generator is a lazy, incrementally-pending list</strong>, and <strong><code>yield</code> statements allow you to use function notation to program the list values</strong> the generator should incrementally spit out.</p>

<pre><code>generator = myYieldingFunction(...)
x = list(generator)

   generator
       v
[x[0], ..., ???]

         generator
             v
[x[0], x[1], ..., ???]

               generator
                   v
[x[0], x[1], x[2], ..., ???]

                       StopIteration exception
[x[0], x[1], x[2]]     done

list==[x[0], x[1], x[2]]
</code></pre>

<hr>

<h2>Example</h2>

<p>Let's define a function <code>makeRange</code> that's just like Python's <code>range</code>. Calling <code>makeRange(n)</code> RETURNS A GENERATOR:</p>

<pre><code>def makeRange(n):
    # return 0,1,2,...,n-1
    i = 0
    while i &lt; n:
        yield i
        i += 1

&gt;&gt;&gt; makeRange(5)
&lt;generator object makeRange at 0x19e4aa0&gt;
</code></pre>

<p>To force the generator to immediately return its pending values, you can pass it into <code>list()</code> (just like you could any iterable):</p>

<pre><code>&gt;&gt;&gt; list(makeRange(5))
[0, 1, 2, 3, 4]
</code></pre>

<hr>

<h2>Comparing example to ""just returning a list""</h2>

<p>The above example can be thought of as merely creating a list which you append to and return:</p>

<pre><code># list-version                   #  # generator-version
def makeRange(n):                #  def makeRange(n):
    """"""return [0,1,2,...,n-1]"""""" #~     """"""return 0,1,2,...,n-1""""""
    TO_RETURN = []               #&gt;
    i = 0                        #      i = 0
    while i &lt; n:                 #      while i &lt; n:
        TO_RETURN += [i]         #~         yield i
        i += 1                   #      i += 1
    return TO_RETURN             #&gt;

&gt;&gt;&gt; makeRange(5)
[0, 1, 2, 3, 4]
</code></pre>

<p>There is one major difference though; see the last section.</p>

<hr>

<h2>How you might use generators</h2>

<p>An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so:</p>

<pre><code>#                   _ITERABLE_
&gt;&gt;&gt; [x+10 for x in makeRange(5)]
[10, 11, 12, 13, 14]
</code></pre>

<p>To get a better feel for generators, you can play around with the <code>itertools</code> module (be sure to use <code>chain.from_iterable</code> rather than <code>chain</code> when warranted). For example, you might even use generators to implement infinitely-long lazy lists like <code>itertools.count()</code>. You could implement your own <code>def enumerate(iterable): zip(count(), iterable)</code>, or alternatively do so with the <code>yield</code> keyword in a while-loop.</p>

<p>Please note: generators can actually be used for many more things, such as <a href=""http://www.dabeaz.com/coroutines/index.html"">implementing coroutines</a> or non-deterministic programming or other elegant things. However, the ""lazy lists"" viewpoint I present here is the most common use you will find.</p>

<hr>

<h2>Behind the scenes</h2>

<p>This is how the ""Python iteration protocol"" works. That is, what is going on when you do <code>list(makeRange(5))</code>. This is what I describe earlier as a ""lazy, incremental list"".</p>

<pre><code>&gt;&gt;&gt; x=iter(range(5))
&gt;&gt;&gt; next(x)
0
&gt;&gt;&gt; next(x)
1
&gt;&gt;&gt; next(x)
2
&gt;&gt;&gt; next(x)
3
&gt;&gt;&gt; next(x)
4
&gt;&gt;&gt; next(x)
Traceback (most recent call last):
  File ""&lt;stdin&gt;"", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>The built-in function <code>next()</code> just calls the objects <code>.next()</code> function, which is a part of the ""iteration protocol"" and is found on all iterators. You can manually use the <code>next()</code> function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that...</p>

<hr>

<h2>Minutiae</h2>

<p>Normally, most people would not care about the following distinctions and probably want to stop reading here.</p>

<p>In Python-speak, an <em>iterable</em> is any object which ""understands the concept of a for-loop"" like a list <code>[1,2,3]</code>, and an <em>iterator</em> is a specific instance of the requested for-loop like <code>[1,2,3].__iter__()</code>. A <em>generator</em> is exactly the same as any iterator, except for the way it was written (with function syntax).</p>

<p>When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself.</p>

<p>Thus, in the unlikely event that you are failing to do something like this...</p>

<pre><code>&gt; x = myRange(5)
&gt; list(x)
[0, 1, 2, 3, 4]
&gt; list(x)
[]
</code></pre>

<p>... then remember that a generator is an <em>iterator</em>; that is, it is one-time-use. If you want to reuse it, you should call <code>myRange(...)</code> again. If you need to use the result twice, convert the result to a list and store it in a variable <code>x = list(myRange(5))</code>. Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use <a href=""https://docs.python.org/2/library/itertools.html#itertools.tee""><code>itertools.tee</code></a> if absolutely necessary, since the copyable iterator Python <a href=""http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development"">PEP</a> standards proposal has been deferred.</p>
"
12716515,,231767.0,20003.0,49,"<p>Here are some <a href=""https://github.com/dustingetz/sandbox/blob/master/etc/lazy.py"">Python examples of how to actually implement generators</a> as if Python did not provide syntactic sugar for them (or in a language without native syntax, like <a href=""http://en.wikipedia.org/wiki/JavaScript"">JavaScript</a>). Snippets from that link is below.</p>

<p><strong>As a Python generator:</strong></p>

<pre><code>from itertools import islice

def fib_gen():
    a, b = 1, 1
    while True:
        yield a
        a, b = b, a + b

assert [1, 1, 2, 3, 5] == list(islice(fib_gen(), 5))
</code></pre>

<p><strong>Using lexical closures instead of generators</strong></p>

<pre><code>def ftake(fnext, last):
    return [fnext() for _ in xrange(last)]

def fib_gen2():
    #funky scope due to python2.x workaround
    #for python 3.x use nonlocal
    def _():
        _.a, _.b = _.b, _.a + _.b
        return _.a
    _.a, _.b = 0, 1
    return _

assert [1,1,2,3,5] == ftake(fib_gen2(), 5)
</code></pre>

<p><strong>Using object closures instead of generators</strong> (because <a href=""http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent"">ClosuresAndObjectsAreEquivalent</a>)</p>

<pre><code>class fib_gen3:
    def __init__(self):
        self.a, self.b = 1, 1

    def __call__(self):
        r = self.a
        self.a, self.b = self.b, self.a + self.b
        return r

assert [1,1,2,3,5] == ftake(fib_gen3(), 5)
</code></pre>
"
14352675,,231767.0,1776798.0,88,"<p>Yield gives you a generator. </p>

<pre><code>def get_odd_numbers(i):
    return range(1, i, 2)
def yield_odd_numbers(i):
    for x in range(1, i, 2):
       yield x
foo = get_odd_numbers(10)
bar = yield_odd_numbers(10)
foo
[1, 3, 5, 7, 9]
bar
&lt;generator object yield_odd_numbers at 0x1029c6f50&gt;
bar.next()
1
bar.next()
3
bar.next()
5
</code></pre>

<p>As you can see, in the first case foo holds the entire list in memory at once. It's not a big deal for a list with 5 elements, but what if you want a list of 5 million? Not only is this a huge memory eater, it also costs a lot of time to build at the time that the function is called. In the second case, bar just gives you a generator. A generator is an iterable--which means you can use it in a for loop, etc, but each value can only be accessed once. All the values are also not stored in memory at the same time; the generator object ""remembers"" where it was in the looping the last time you called it--this way, if you're using an iterable to (say) count to 50 billion, you don't have to count to 50 billion all at once and store the 50 billion numbers to count through. Again, this is a pretty contrived example, you probably would use itertools if you really wanted to count to 50 billion. :)</p>

<p>This is the most simple use case of generators. As you said, it can be used to write efficient permutations, using yield to push things up through the call stack instead of using some sort of stack variable. Generators can also be used for specialized tree traversal, and all manner of other things.</p>
"
14404292,,231767.0,1531346.0,95,"<p>For those who prefer a minimal working example, meditate on this interactive <a href=""http://en.wikipedia.org/wiki/Python_%28programming_language%29"">Python</a> session:</p>

<pre><code>&gt;&gt;&gt; def f():
...   yield 1
...   yield 2
...   yield 3
... 
&gt;&gt;&gt; g = f()
&gt;&gt;&gt; for i in g:
...   print i
... 
1
2
3
&gt;&gt;&gt; for i in g:
...   print i
... 
&gt;&gt;&gt; # Note that this time nothing was printed
</code></pre>
"
14554322,,231767.0,479213.0,51,"<p>I was going to post ""read page 19 of Beazley's 'Python: Essential Reference' for a quick description of generators"", but so many others have posted good descriptions already.</p>

<p>Also, note that <code>yield</code> can be used in coroutines as the dual of their use in generator functions.  Although it isn't the same use as your code snippet, <code>(yield)</code> can be used as an expression in a function.  When a caller sends a value to the method using the <code>send()</code> method, then the coroutine will execute until the next <code>(yield)</code> statement is encountered.</p>

<p>Generators and coroutines are a cool way to set up data-flow type applications.  I thought it would be worthwhile knowing about the other use of the <code>yield</code> statement in functions.</p>
"
15814755,,231767.0,2040716.0,81,"<p>There is one type of answer that I don't feel has been given yet, among the many great answers that describe how to use generators.  Here is the PL theory answer:</p>

<p>The <code>yield</code> statement in python returns a generator.  A generator in python is a function that returns <i>continuations</i> (and specifically a type of coroutine, but continuations represent the more general mechanism to understand what is going on).</p>

<p>Continuations in programming languages theory are a much more fundamental kind of computation, but they are not often used because they are extremely hard to reason about and also very difficult to implement.  But the idea of what a continuation is, is straightforward: it is the state of a computation that has not yet finished. In this state are saved the current values of variables and the operations that have yet to be performed, and so on. Then at some point later in the program the continuation can be invoked, such that the program's variables are reset to that state and the operations that were saved are carried out.</p>

<p>Continuations, in this more general form, can be implemented in two ways. In the <code>call/cc</code> way, the program's stack is literally saved and then when the continuation is invoked, the stack is restored.</p>

<p>In continuation passing style (CPS), continuations are just normal functions (only in languages where functions are first class) which the programmer explicitly manages and passes around to subroutines. In this style, program state is represented by closures (and the variables that happen to be encoded in them) rather than variables that reside somewhere on the stack. Functions that manage control flow accept continuation as arguments (in some variations of CPS, functions may accept multiple continuations) and manipulate control flow by invoking them by simply calling them and returning afterwards. A very simple example of continuation passing style is as follows:</p>

<pre><code>def save_file(filename):
  def write_file_continuation():
    write_stuff_to_file(filename)

  check_if_file_exists_and_user_wants_to_overwrite( write_file_continuation )
</code></pre>

<p>In this (very simplistic) example, the programmer saves the operation of actually writing the file into a continuation (which can potentially be a very complex operation with many details to write out), and then passes that continuation (i.e, as a first-class closure) to another operator which does some more processing, and then calls it if necessary. (I use this design pattern a lot in actual GUI programming, either because it saves me lines of code or, more importantly, to manage control flow after GUI events trigger)</p>

<p>The rest of this post will, without loss of generality, conceptualize continuations as CPS, because it is a hell of a lot easier to understand and read.</p>

<p><br></p>

<p>Now let's talk about generators in python. Generators are a specific subtype of continuation. Whereas <strong>continuations are able in general to save the state of a <em>computation</em></strong> (i.e., the program's call stack), <strong>generators are only able to save the state of iteration over an <em>iterator</em></strong>. Although, this definition is slightly misleading for certain use cases of generators. For instance:</p>

<pre><code>def f():
  while True:
    yield 4
</code></pre>

<p>This is clearly a reasonable iterable whose behavior is well defined -- each time the generator iterates over it, it returns 4 (and does so forever). But it isn't probably the prototypical type of iterable that comes to mind when thinking of iterators (i.e., <code>for x in collection: do_something(x)</code>). This example illustrates the power of generators: if anything is an iterator, a generator can save the state of its iteration.</p>

<p>To reiterate: Continuations can save the state of a program's stack and generators can save the state of iteration. This means that continuations are more a lot powerful than generators, but also that generators are a lot, lot easier. They are easier for the language designer to implement, and they are easier for the programmer to use (if you have some time to burn, try to read and understand <a href=""http://www.madore.org/~david/computers/callcc.html"">this page about continuations and call/cc</a>).</p>

<p>But you could easily implement (and conceptualize) generators as a simple, specific case of continuation passing style: </p>

<p>Whenever <code>yield</code> is called, it tells the function to return a continuation.  When the function is called again, it starts from wherever it left off. So, in pseudo-pseudocode  (i.e., not pseudocode but not code) the generator's <code>next</code> method is basically as follows: </p>

<pre><code>class Generator():
  def __init__(self,iterable,generatorfun):
    self.next_continuation = lambda:generatorfun(iterable)

  def next(self):
    value, next_continuation = self.next_continuation()
    self.next_continuation = next_continuation
    return value
</code></pre>

<p>where <code>yield</code> keyword is actually syntactic sugar for the real generator function, basically something like:</p>

<pre><code>def generatorfun(iterable):
  if len(iterable) == 0:
    raise StopIteration
  else:
    return (iterable[0], lambda:generatorfun(iterable[1:]))
</code></pre>

<p>Remember that this is just pseudocode and the actual implementation of generators in python is more complex. But as an exercise to understand what is going on, try to use continuation passing style to implement generator objects without use of the <code>yield</code> keyword.</p>
"
17113322,,231767.0,1143274.0,34,"<p>Here is a mental image of what <code>yield</code> does.</p>

<p>I like to think of a thread as having a stack (even if it's not implemented that way).</p>

<p>When a normal function is called, it puts its local variables on the stack, does some computation, returns and clears the stack. The values of its local variables are never seen again.</p>

<p>With a <code>yield</code> function, when it's called first, it similarly adds its local variables to the stack, but then takes its local variables to a special hideaway instead of clearing them, when it returns via <code>yield</code>. A possible place to put them would be somewhere in the heap.</p>

<p>Note that it's not <em>the function</em> any more, it's a kind of an imprint or ghost of the function that the <code>for</code> loop is hanging onto.</p>

<p>When it is called again, it retrieves its local variables from its special hideaway and puts them back on the stack and computes, then hides them again in the same way.</p>
"
18365578,,231767.0,1419272.0,33,"<p>From a programming viewpoint, the iterators are implemented as <strong>thunks</strong> </p>

<p><a href=""http://en.wikipedia.org/wiki/Thunk_(functional_programming)"">http://en.wikipedia.org/wiki/Thunk_(functional_programming)</a></p>

<p>To implement iterators/generators/etc as thunks (also called anonymous functions), one uses messages sent to a closure object, which has a dispatcher, and the dispatcher answers to ""messages"".</p>

<p><a href=""http://en.wikipedia.org/wiki/Message_passing"">http://en.wikipedia.org/wiki/Message_passing</a></p>

<p>""<em>next</em>"" is a message sent to a closure, created by ""<em>iter</em>"" call.</p>

<p>There are lots of ways to implement this computation.  I used mutation but it is easy to do it without mutation, by returning the current value and the next yielder.</p>

<p>Here is a demonstration which uses the structure of R6RS but the semantics is absolutely identical as in python, it's the same model of computation, only a change in syntax is required to rewrite it in python.</p>

<blockquote>
<pre><code>Welcome to Racket v6.5.0.3.

-&gt; (define gen
     (lambda (l)
       (define yield
         (lambda ()
           (if (null? l)
               'END
               (let ((v (car l)))
                 (set! l (cdr l))
                 v))))
       (lambda(m)
         (case m
           ('yield (yield))
           ('init  (lambda (data)
                     (set! l data)
                     'OK))))))
-&gt; (define stream (gen '(1 2 3)))
-&gt; (stream 'yield)
1
-&gt; (stream 'yield)
2
-&gt; (stream 'yield)
3
-&gt; (stream 'yield)
'END
-&gt; ((stream 'init) '(a b))
'OK
-&gt; (stream 'yield)
'a
-&gt; (stream 'yield)
'b
-&gt; (stream 'yield)
'END
-&gt; (stream 'yield)
'END
-&gt; 
</code></pre>
</blockquote>
"
20704301,,231767.0,1077381.0,41,"<p>Here is a simple example:</p>

<pre><code>def isPrimeNumber(n):
    print ""isPrimeNumber({}) call"".format(n)
    if n==1:
        return False
    for x in range(2,n):
        if n % x == 0:
            return False
    return True



def primes (n=1):
    while(True):
        print ""loop step ---------------- {}"".format(n)
        if isPrimeNumber(n): yield n
        n += 1

for n in primes():
    if n&gt; 10:break
    print ""wiriting result {}"".format(n)   
</code></pre>

<p>output :</p>

<pre><code>loop step ---------------- 1
isPrimeNumber(1) call
loop step ---------------- 2
isPrimeNumber(2) call
loop step ---------------- 3
isPrimeNumber(3) call
wiriting result 3
loop step ---------------- 4
isPrimeNumber(4) call
loop step ---------------- 5
isPrimeNumber(5) call
wiriting result 5
loop step ---------------- 6
isPrimeNumber(6) call
loop step ---------------- 7
isPrimeNumber(7) call
wiriting result 7
loop step ---------------- 8
isPrimeNumber(8) call
loop step ---------------- 9
isPrimeNumber(9) call
loop step ---------------- 10
isPrimeNumber(10) call
loop step ---------------- 11
isPrimeNumber(11) call
</code></pre>

<p>I am not a Python developer, but it looks to me <code>yield</code> holds the position of program flow and the next loop start from ""yield"" position. It seems like it is waiting at that position, and just before that, returning a value outside, and next time continues to work.</p>

<p>Seems to me an interesting and nice ability :D </p>
"
21541902,,231767.0,2379433.0,64,"<p>While a lot of answers show why you'd use a <code>yield</code> to create a generator, there are more uses for <code>yield</code>.  It's quite easy to make a coroutine, which enables the passing of information between two blocks of code.  I won't repeat any of the fine examples that have already been given about using <code>yield</code> to create a generator.</p>

<p>To help understand what a <code>yield</code> does in the following code, you can use your finger to trace the cycle through any code that has a <code>yield</code>.  Every time your finger hits the <code>yield</code>, you have to wait for a <code>next</code> or a <code>send</code> to be entered.  When a <code>next</code> is called, you trace through the code until you hit the <code>yield</code>â¦ the code on the right of the <code>yield</code> is evaluated and returned to the callerâ¦ then you wait.  When <code>next</code> is called again, you perform another loop through the code.  However, you'll note that in a coroutine, <code>yield</code> can also be used with a <code>send</code>â¦ which will send a value from the caller <em>into</em> the yielding function. If a <code>send</code> is given, then <code>yield</code> receives the value sent, and spits it out the left hand sideâ¦ then the trace through the code progresses until you hit the <code>yield</code> again (returning the value at the end, as if <code>next</code> was called).</p>

<p>For example:</p>

<pre><code>&gt;&gt;&gt; def coroutine():
...     i = -1
...     while True:
...         i += 1
...         val = (yield i)
...         print(""Received %s"" % val)
...
&gt;&gt;&gt; sequence = coroutine()
&gt;&gt;&gt; sequence.next()
0
&gt;&gt;&gt; sequence.next()
Received None
1
&gt;&gt;&gt; sequence.send('hello')
Received hello
2
&gt;&gt;&gt; sequence.close()
</code></pre>
"
24944096,,231767.0,1416144.0,49,"<p>There is another <code>yield</code> use and meaning (since python 3.3):</p>

<pre><code>yield from &lt;expr&gt;
</code></pre>

<p><a href=""http://www.python.org/dev/peps/pep-0380/"">http://www.python.org/dev/peps/pep-0380/</a></p>

<blockquote>
  <p>A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.</p>
  
  <p>The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another.</p>
</blockquote>

<p>moreover <a href=""https://www.python.org/dev/peps/pep-0492/"">this</a> will introduce (since python 3.5):</p>

<pre><code>async def new_coroutine(data):
   ...
   await blocking_action()
</code></pre>

<p>to avoid coroutines confused with regular generator (today <code>yield</code> is used in both).</p>
"
30341713,,231767.0,4884103.0,24,"<p><code>yield</code> is like a return element for a function. The difference is, that the <code>yield</code> element turns a function into a generator. A generator behaves just like a function until something is 'yielded'. The generator stops until it is next called, and continues from exactly the same point as it started. You can get a sequence of all the 'yielded' values in one, by calling <code>list(generator())</code>.</p>
"
31042491,,231767.0,541136.0,113,"<blockquote>
  <p><strong>What does the <code>yield</code> keyword do in Python?</strong></p>
</blockquote>

<h1>Answer Outline/Summary</h1>

<ul>
<li>A function with <a href=""https://docs.python.org/reference/expressions.html#yieldexpr""><strong><code>yield</code></strong></a>, when called, <strong>returns a <a href=""https://docs.python.org/2/tutorial/classes.html#generators"">Generator</a>.</strong></li>
<li>Generators are iterators because they implement the <a href=""https://docs.python.org/2/library/stdtypes.html#iterator-types""><strong>iterator protocol</strong></a>, so you can iterate over them.</li>
<li>A generator can also be <strong>sent information</strong>, making it conceptually a <strong>coroutine</strong>.</li>
<li>In Python 3, you can <strong>delegate</strong> from one generator to another in both directions with <strong><code>yield from</code></strong>.</li>
</ul>

<h1>Generators:</h1>

<p><strong><code>yield</code></strong> is only legal inside of a function definition, and <strong>the inclusion of <code>yield</code> in a function definition makes it return a generator.</strong></p>

<p>The idea for generators comes from other languages (see footnote 1) with varying implementations. In Python's Generators, the execution of the code is <a href=""https://docs.python.org/3.5/glossary.html#term-generator-iterator"">frozen</a> at the point of the yield. When the generator is called (methods are discussed below) execution resumes and then freezes at the next yield.</p>

<p><code>yield</code> provides an 
easy way of <a href=""https://docs.python.org/2/library/stdtypes.html#generator-types"">implementing the iterator protocol</a>, defined by the following two methods: 
<code>__iter__</code> and <code>next</code> (Python 2) or <code>__next__</code> (Python 3).  Both of those methods
make an object an iterator that you could type-check with the <code>Iterator</code> Abstract Base 
Class from the <code>collections</code> module.</p>

<pre><code>&gt;&gt;&gt; def func():
...     yield 'I am'
...     yield 'a generator!'
... 
&gt;&gt;&gt; type(func)                 # A function with yield is still a function
&lt;type 'function'&gt;
&gt;&gt;&gt; gen = func()
&gt;&gt;&gt; type(gen)                  # but it returns a generator
&lt;type 'generator'&gt;
&gt;&gt;&gt; hasattr(gen, '__iter__')   # that's an iterable
True
&gt;&gt;&gt; hasattr(gen, 'next')       # and with .next (.__next__ in Python 3)
True                           # implements the iterator protocol.
</code></pre>

<p>The generator type is a sub-type of iterator:</p>

<pre><code>&gt;&gt;&gt; import collections, types
&gt;&gt;&gt; issubclass(types.GeneratorType, collections.Iterator)
True
</code></pre>

<p>And if necessary, we can type-check like this:</p>

<pre><code>&gt;&gt;&gt; isinstance(gen, types.GeneratorType)
True
&gt;&gt;&gt; isinstance(gen, collections.Iterator)
True
</code></pre>

<p>A feature of an <code>Iterator</code> <a href=""https://docs.python.org/2/glossary.html#term-iterator"">is that once exhausted</a>, you can't reuse or reset it:</p>

<pre><code>&gt;&gt;&gt; list(gen)
['I am', 'a generator!']
&gt;&gt;&gt; list(gen)
[]
</code></pre>

<p>You'll have to make another if you want to use its functionality again (see footnote 2):</p>

<pre><code>&gt;&gt;&gt; list(func())
['I am', 'a generator!']
</code></pre>

<p>One can yield data programmatically, for example:</p>

<pre><code>def func(an_iterable):
    for item in an_iterable:
        yield item
</code></pre>

<p>The above simple generator is also equivalent to the below - as of Python 3.3 (and not available in Python 2), you can use <a href=""https://www.python.org/dev/peps/pep-0380/""><code>yield from</code></a>:</p>

<pre><code>def func(an_iterable):
    yield from an_iterable
</code></pre>

<p>However, <code>yield from</code> also allows for delegation to subgenerators, 
which will be explained in the following section on cooperative delegation with sub-coroutines.</p>

<h1>Coroutines:</h1>

<p><code>yield</code> forms an expression that allows data to be sent into the generator (see footnote 3)</p>

<p>Here is an example, take note of the <code>received</code> variable, which will point to the data that is sent to the generator:</p>

<pre><code>def bank_account(deposited, interest_rate):
    while True:
        calculated_interest = interest_rate * deposited 
        received = yield calculated_interest
        if received:
            deposited += received


&gt;&gt;&gt; my_account = bank_account(1000, .05)
</code></pre>

<p>First, we must queue up the generator with the builtin function, <a href=""https://docs.python.org/2/library/functions.html#next""><code>next</code></a>. It will 
call the appropriate <code>next</code> or <code>__next__</code> method, depending on the version of
Python you are using:</p>

<pre><code>&gt;&gt;&gt; first_year_interest = next(my_account)
&gt;&gt;&gt; first_year_interest
50.0
</code></pre>

<p>And now we can send data into the generator. (<a href=""https://www.python.org/dev/peps/pep-0342/"">Sending <code>None</code> is 
the same as calling <code>next</code></a>.) :</p>

<pre><code>&gt;&gt;&gt; next_year_interest = my_account.send(first_year_interest + 1000)
&gt;&gt;&gt; next_year_interest
102.5
</code></pre>

<h2>Cooperative Delegation to Sub-Coroutine with <code>yield from</code></h2>

<p>Now, recall that <code>yield from</code> is available in Python 3. This allows us to delegate
coroutines to a subcoroutine:</p>

<pre><code>def money_manager(expected_rate):
    under_management = yield     # must receive deposited value
    while True:
        try:
            additional_investment = yield expected_rate * under_management 
            if additional_investment:
                under_management += additional_investment
        except GeneratorExit:
            '''TODO: write function to send unclaimed funds to state'''
        finally:
            '''TODO: write function to mail tax info to client'''


def investment_account(deposited, manager):
    '''very simple model of an investment account that delegates to a manager'''
    next(manager) # must queue up manager
    manager.send(deposited)
    while True:
        try:
            yield from manager
        except GeneratorExit:
            return manager.close()
</code></pre>

<p>And now we can delegate functionality to a sub-generator and it can be used
by a generator just as above:</p>

<pre><code>&gt;&gt;&gt; my_manager = money_manager(.06)
&gt;&gt;&gt; my_account = investment_account(1000, my_manager)
&gt;&gt;&gt; first_year_return = next(my_account)
&gt;&gt;&gt; first_year_return
60.0
&gt;&gt;&gt; next_year_return = my_account.send(first_year_return + 1000)
&gt;&gt;&gt; next_year_return
123.6
</code></pre>

<p>You can read more about the precise semantics of <code>yield from</code> in <a href=""https://www.python.org/dev/peps/pep-0380/#formal-semantics"">PEP 380.</a></p>

<h2>Other Methods: close and throw</h2>

<p>The <code>close</code> method raises <code>GeneratorExit</code> at the point the function 
execution was frozen. This will also be called by <code>__del__</code> so you 
can put any cleanup code where you handle the <code>GeneratorExit</code>:</p>

<pre><code>&gt;&gt;&gt; my_account.close()
</code></pre>

<p>You can also throw an exception which can be handled in the generator
or propagated back to the user:</p>

<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; try:
...     raise ValueError
... except:
...     my_manager.throw(*sys.exc_info())
... 
Traceback (most recent call last):
  File ""&lt;stdin&gt;"", line 4, in &lt;module&gt;
  File ""&lt;stdin&gt;"", line 2, in &lt;module&gt;
ValueError
</code></pre>

<h1>Conclusion</h1>

<p>I believe I have covered all aspects of the following question:</p>

<blockquote>
  <p><strong>What does the <code>yield</code> keyword do in Python?</strong></p>
</blockquote>

<p>It turns out that <code>yield</code> does a lot. I'm sure I could add even more 
thorough examples to this. If you want more or have some constructive criticism, let me know by commenting
below.</p>

<hr>

<h1>Appendix:</h1>

<h2>Critique of the Top/Accepted Answer**</h2>

<ul>
<li>It is confused on what makes an <strong>iterable</strong>, just using a list as an example. See my references above, but in summary: an iterable has an <code>__iter__</code> method returning an <strong>iterator</strong>. An <strong>iterator</strong> provides a <code>.next</code> (Python 2 or <code>.__next__</code> (Python 3) method, which is implicitly called by <code>for</code> loops until it raises <code>StopIteration</code>, and once it does, it will continue to do so.</li>
<li>It then uses a generator expression to describe what a generator is. Since a generator is simply a convenient way to create an <strong>iterator</strong>, it only confuses the matter, and we still have not yet gotten to the <code>yield</code> part.</li>
<li>In <strong>Controlling a generator exhaustion</strong> he calls the <code>.next</code> method, when instead he should use the builtin function, <code>next</code>. It would be an appropriate layer of indirection, because his code does not work in Python 3.</li>
<li>Itertools? This was not relevant to what <code>yield</code> does at all.</li>
<li>No discussion of the methods that <code>yield</code> provides along with the new functionality <code>yield from</code> in Python 3. <strong>The top/accepted answer is a very incomplete answer.</strong></li>
</ul>

<h2>The <code>return</code> statement in a generator</h2>

<p>In <a href=""https://docs.python.org/2/reference/simple_stmts.html#the-return-statement"">Python 2</a>:</p>

<blockquote>
  <p>In a generator function, the <code>return</code> statement is not allowed to include an <code>expression_list</code>. In that context, a bare <code>return</code> indicates that the generator is done and will cause <code>StopIteration</code> to be raised.</p>
</blockquote>

<p>An <code>expression_list</code> is basically any number of expressions separated by commas - essentially, in Python 2, you can stop the generator with <code>return</code>, but you can't return a value.</p>

<p>In <a href=""https://docs.python.org/3/reference/simple_stmts.html#the-return-statement"">Python 3</a>: </p>

<blockquote>
  <p>In a generator function, the <code>return</code> statement indicates that the generator is done and will cause <code>StopIteration</code> to be raised. The returned value (if any) is used as an argument to construct <code>StopIteration</code> and becomes the <code>StopIteration.value</code> attribute.</p>
</blockquote>

<h2>Footnotes</h2>

<ol>
<li><p><sub>The languages CLU, Sather, and Icon were referenced in the proposal
to introduce the concept of generators to Python. The general idea is
that a function can maintain internal state and yield intermediate 
data points on demand by the user. This promised to be <a href=""https://www.python.org/dev/peps/pep-0255/"">superior in performance 
to other approaches, including Python threading</a>, which isn't even available on some systems.</sub></p></li>
<li><p><sub> This means, for example, that <code>xrange</code> objects (<code>range</code> in Python 3) aren't <code>Iterator</code>s, even though they are iterable, because they can be reused. Like lists, their <code>__iter__</code> methods return iterator objects.</sub></p></li>
<li><p><sub> 
<code>yield</code> was originally introduced as a statement, meaning that it 
could only appear at the beginning of a line in a code block. 
Now <code>yield</code> creates a yield expression. 
<a href=""https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt"">https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt</a> 
This change was <a href=""https://www.python.org/dev/peps/pep-0342/"">proposed</a> to allow a user to send data into the generator just as
one might receive it. To send data, one must be able to assign it to something, and
for that, a statement just won't work.</sub></p></li>
</ol>
"
31692481,,231767.0,2393267.0,24,"<p>Like every answer suggests, <code>yield</code> is used for creating a sequence generator. It's used for generating some sequence dynamically. Eg. While reading a file line by line on a network, you can use the <code>yield</code> function as follows:</p>

<pre><code>def getNextLines():
   while con.isOpen():
       yield con.read()
</code></pre>

<p>You can use it in your code as follows :</p>

<pre><code>for line in getNextLines():
    doSomeThing(line)
</code></pre>

<p><strong><em>Execution Control Transfer gotcha</em></strong></p>

<p>The execution control will be transferred from getNextLines() to the for loop when yield is executed. Thus, every time getNextLines() is invoked, execution begins from the point where it was paused last time.</p>

<p>Thus in short, a function with the following code</p>

<pre><code>def simpleYield():
    yield ""first time""
    yield ""second time""
    yield ""third time""
    yield ""Now some useful value {}"".format(12)

for i in simpleYield():
    print i
</code></pre>

<p>will print </p>

<pre><code>""first time""
""second time""
""third time""
""Now some useful value 12""
</code></pre>

<p>I hope this helps you.</p>
"
32331953,,231767.0,2046817.0,18,"<p><strong>Yield is an Object</strong></p>

<p>A <code>return</code> in a function will return a single value.</p>

<p>If you want <strong>function to return huge set of values</strong> use <code>yield</code>.</p>

<p>More importantly, <code>yield</code> is a <strong>barrier</strong> </p>

<blockquote>
  <p>like Barrier in Cuda Language, it will not transfer control until it gets
  completed.</p>
</blockquote>

<p>i.e</p>

<p>It will run the code in your function from the beginning until it hits <code>yield</code>. Then, itâll return the first value of the loop. 
Then, every other call will run the loop you have written in the function one more time, returning the next value until there is no value to return.</p>
"
33788856,,231767.0,5069117.0,17,"<p>The <code>yield</code> keyword simply collects returning results. Think of <code>yield</code> like <code>return +=</code></p>
"
35526740,,231767.0,4952130.0,12,"<h3>Official Reference on <code>yield</code> : <strong><a href=""https://www.python.org/dev/peps/pep-0255/"">PEP 255 -- Simple Generators</a></strong>:</h3>

<p>Most questions regarding the <code>yield</code> statement and the semantics/functionality that it introduces are present in <em>PEP 255</em>. The collective knowledge from all previous answers is amazing but I'll add an answer that references the official presentation.</p>

<p>So first of, the form of the <code>yield</code> statement:</p>

<pre><code>yield_stmt:    ""yield"" expression_list
</code></pre>

<p>consist of the <em>keyword</em> <strong>yield</strong> along with an optional <code>expression_list</code>. </p>

<p>Syntactically yield can only appear inside a function definition and its presence alone is responsible for tranforming a function into a generator object:</p>

<blockquote>
  <p>The yield statement may only be used inside functions.  A function
  that contains a <code>yield</code> statement is called a <a href=""http://stackoverflow.com/questions/1756096/understanding-generators-in-python"">generator</a> function.  A generator function is an ordinary function object in all respects, but has the new <code>CO_GENERATOR</code> flag set in the code object's <code>co_flags</code> member.</p>
</blockquote>

<p>So after you define your generator you're left with a generator function that is waiting to be called: </p>

<blockquote>
  <p>When a generator function is called, the actual arguments are bound to
  function-local formal argument names in the usual way, <em>but no code in</em>
  <em>the body of the function is executed.</em>  </p>
</blockquote>

<p>So parameters are bound in the same way as they do for all callable but the body of the generator object is not executed, what happens is:</p>

<blockquote>
  <p>Instead a generator-iterator object is returned; this conforms to the iterator protocol[6], so in particular can be used in for-loops in a natural way.</p>
</blockquote>

<p>We get back an object that comforms to the <strong><a href=""https://docs.python.org/2/library/stdtypes.html#iterator-types""><em>iterator protocol</em></a></strong> this means that the <code>generator</code> object implements <code>__iter__</code> and <code>__next__</code> and as such can be used in <code>for</code> loops like any object that supports iteration. </p>

<p>The key difference that <code>yield</code> makes is here, specifically:</p>

<blockquote>
  <p>Each time the <code>.next()</code> method of a generator-iterator is invoked, the
  code in the body of the generator-function is executed until a <code>yield</code>
  or <code>return</code> statement (see below) is encountered, or until the end of
  the body is reached.</p>
</blockquote>

<p>So everything <em>until</em> the <code>yield</code> is executed and then execution stops, at that point what happens is: </p>

<blockquote>
  <p>If a <code>yield</code> statement is encountered, the state of the function is
  frozen, and the value of expression_list is returned to <code>.next()</code>'s
  caller.</p>
</blockquote>

<p>So in the case of a <code>for</code> loop: <code>for i in gen_func(params): pass</code> the value of <code>i</code> is going to be equal to <code>expression_list</code> as previously stated.</p>

<p>But ""frozen"" you may ask, what does that mean? This is further explained as: </p>

<blockquote>
  <p>By ""frozen"" we mean that all local state is retained, including the
  current bindings of local variables, the instruction pointer, and the
  internal evaluation stack:  enough information is saved so that the
  next time .next() is invoked, the function can proceed exactly as if
  the yield statement were just another external call.</p>
</blockquote>

<p>So state is retained when <code>yield</code> is encountered thereby allowing consequent calls to <code>next</code> to continue smoothly. When a <code>next</code> call is made the generator is going to execute everything until it finds another <code>yield</code> statement. That cicle is repeated until no <code>yield</code> (i.e control flows off the end of the generator) or a <code>return</code> is found in which case a <code>StopIteration</code> exception is raised signalling that the generator has been exhausted.</p>
"
36168155,,231767.0,5796943.0,10,"<p>At a glance, the yield statement is used to define generators, replacing the return of a function to provide a result to its caller without destroying local variables. Unlike a function, where on each call it starts with new set of variables, a generator will resume the execution where it was left off.</p>

<p>About Python Generators
Since the yield keyword is only used with generators, it makes sense to recall the concept of generators first.</p>

<p>The idea of generators is to calculate a series of results one-by-one on demand (on the fly). In the simplest case, a generator can be used as a list, where each element is calculated lazily. Let's compare a list and a generator that do the same thing - return powers of two:</p>

<p>Iterating over the list and the generator looks completely the same. However, although the generator is iterable, it is not a collection and thus has no length. Collections (lists, tuples, sets, etc) keep all values in memory and we can access them whenever needed. A generator calculates the values on the fly and forgets them, so it does not have any overview about the own result set.</p>

<p>Generators are especially useful for memory-intensive tasks, where there is no need to keep all of the elements of a memory-heavy list accessible at the same time. Calculating a series of values one-by-one can also be useful in situations where the complete result is never needed, yielding intermediate results to the caller until some requirement is satisfied and further processing stops.</p>

<p>Using the Python ""yield"" keyword
A good example is a search task, where typically there is no need to wait for all results to be found. Performing a file-system search, a user would be happier to receive results on-the-fly, rather the wait for a search engine to go through every single file and only afterwards return results. Are there any people who really navigate through all Google search results until the last page?</p>

<p>Since a search functionality cannot be created using list-comprehensions, we are going to define a generator using a function with the yield statement/keyword. The yield instruction should be put into a place where the generator returns an intermediate result to the caller and sleeps until the next invocation occurs. </p>

<p>So far the most practical aspects of Python generators have been described. For more detailed info and an interesting discussion take a look at the Python Enhancement Proposal 255, which discusses the feature of the language in detail.</p>

<p>Happy Pythoning!
<strong>For more info go to <a href=""http://pythoncentral.io/python-generators-and-yield-keyword/"">http://pythoncentral.io/python-generators-and-yield-keyword/</a></strong></p>
"
36214653,,231767.0,264052.0,14,"<p>(My below answer only speaks from the perspective of using Python generator, not the <a href=""http://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython"">underlying implementation of generator mechanism</a>, which involves some tricks of stack and heap manipulation.)</p>

<p>When <code>yield</code> is used instead of a <code>return</code> in a python function, that function is turned into something special called <code>generator function</code>. That function will return an object of <code>generator</code> type. <strong>The <code>yield</code> keyword is a flag to notify the python compiler to treat such function specially.</strong> Normal functions will terminate once some value is returned from it. But with the help of the compiler, the generator function <strong>can be thought of</strong> as resumable. That is, the execution context will be restored and the execution will continue from last run. Until you explicitly call return, which will raise a <code>StopIteration</code> exception (which is also part of the iterator protocol), or reach the end of the function. I found a lot of references about <code>generator</code> but this <a href=""https://docs.python.org/dev/howto/functional.html#generators"" rel=""nofollow"">one</a> from the <code>functional programming perspective</code> is the most digestable.</p>

<p>(Now I want to talk about the rationale behind <code>generator</code>, and the <code>iterator</code> based on my own understanding. I hope this can help you grasp the <strong><em>essential motivation</em></strong> of iterator and generator. Such concept shows up in other languages as well such as C#.)</p>

<p>As I understand, when we want to process a bunch of data, we usually first store the data somewhere and then process it one by one. But this <strong><em>intuitive</em></strong> approach is problematic. If the data volume is huge, it's expensive to store them as a whole beforehand. <strong>So instead of storing the <code>data</code> itself directly, why not store some kind of <code>metadata</code> indirectly, i.e. <code>the logic how the data is computed</code></strong>. </p>

<p>There are 2 approaches to wrap such metadata.</p>

<ol>
<li>The OO approach, we wrap the metadata <code>as a class</code>. This is the so-called <code>iterator</code> who implements the iterator protocol (i.e. the <code>__next__()</code>, and <code>__iter__()</code> methods). This is also the commonly seen <a href=""https://en.wikipedia.org/wiki/Iterator_pattern#Python"" rel=""nofollow"">iterator design pattern</a>.</li>
<li>The functional approach, we wrap the metadata <code>as a function</code>. This is
the so-called <code>generator function</code>. But under the hood, the returned <code>generator object</code> still <code>IS-A</code> iterator because it also implements the iterator protocol.</li>
</ol>

<p>Either way, an iterator is created, i.e. some object that can give you the data you want. The OO approach may be a bit complex. Anyway, which one to use is up to you.</p>
"
36220775,,231767.0,673991.0,27,"<p><strong>TL;DR</strong></p>

<h1>When you find yourself building a list from scratch...</h1>

<pre><code>def squares_list(n):
    the_list = []
    for x in range(n):
        y = x * x
        the_list.append(y)
    return the_list
</code></pre>

<h1>...you may want to yield the pieces instead.</h1>

<pre><code>def squares_the_yield_way(n):
    for x in range(n):
        y = x * x
        yield y
</code></pre>

<p>This was my first aha-moment with yield.</p>

<hr>

<p><code>yield</code> is a sugary way to say </p>

<blockquote>
  <p>build a series of stuff</p>
</blockquote>

<p>Same behavior:</p>

<pre><code>&gt;&gt;&gt; for square in squares_list(4):
...     print(square)
...
0
1
4
9
&gt;&gt;&gt; for square in squares_the_yield_way(4):
...     print(square)
...
0
1
4
9
</code></pre>

<p>Different behavior:</p>

<p>Yield is <strong>single-use</strong>: you can only iterate through once. Conceptually the yield-function returns an ordered container of things. But it's revealing that we call any function with a yield in it a <a href=""http://stackoverflow.com/a/1756342/673991"">generator function</a>. And the term for what it returns is an <a href=""http://stackoverflow.com/a/9884501/673991"">iterator</a>.</p>

<p>Yield is <strong>lazy</strong>, it puts off computation until you need it. A function with a yield in it <em>doesn't actually execute at all</em> when you call it. The iterator object it returns uses <a href=""https://docs.python.org/reference/simple_stmts.html#yield"" rel=""nofollow"">magic</a> to maintain the function's internal context. Each time you call <code>next()</code> on the iterator (as happens in a for-loop), execution inches forward to the next yield. (Or <code>return</code>, which raises <code>StopIteration</code> and ends the series.)</p>

<p>Yield is <strong>versatile</strong>. It can do infinite loops:</p>

<pre><code>&gt;&gt;&gt; def squares_all_of_them():
...     x = 0
...     while True:
...         yield x * x
...         x += 1
...
&gt;&gt;&gt; squares = squares_all_of_them()
&gt;&gt;&gt; for i in range(6):
...     print(squares.next())
...
0
1
4
9
16
25
</code></pre>

<hr>

<p>Brilliant choice of the word <code>yield</code> because <a href=""https://www.google.com/search?q=yield+meaning"" rel=""nofollow"">both meanings of the verb</a> apply:</p>

<blockquote>
  <p><strong>yield</strong> &mdash; produce or provide (as in agriculture)</p>
</blockquote>

<p>...provide the next data in the series.</p>

<blockquote>
  <p><strong>yield</strong> &mdash; give way or relinquish (as in political power)</p>
</blockquote>

<p>...relinquish CPU execution until the iterator advances.</p>
"
37964180,,231767.0,657427.0,8,"<p>Yet another TL;DR</p>

<p><strong>iterator on list</strong>: <code>next()</code> returns the next element of the list</p>

<p><strong>iterator generator</strong>: <code>next()</code> will compute the next element on the fly</p>

<p>You can see the yield/generator as a way to manually run the <strong>control flow</strong> from outside (like continue loop 1 step), by calling next, however complex the flow.</p>

<p>NOTE: the generator is <strong>NOT</strong> a normal function, it remembers previous state like local variables (stack), see other answers or articles for detailed explanation, the generator can only be <strong>iterated on once</strong>.
You could do without <code>yield</code> but it would not be as nice, so it can be considered 'very nice' language sugar.</p>
"
39425637,,231767.0,5177604.0,4,"<p>Many people use <code>return</code> rather than <code>yield</code> but in some cases <code>yield</code> can be more efficient and easier to work with.</p>

<p>Here is an example which <code>yield</code> is definitely best for:</p>

<pre><code>import random

def return_dates():
    dates = [] # with return you need to create a list then return it
    for i in range(5):
        date = random.choice([""1st"", ""2nd"", ""3rd"", ""4th"", ""5th"", ""6th"", ""7th"", ""8th"", ""9th"", ""10th""])
        dates.append(date)
    return dates

def yield_dates():
    for i in range(5):
        date = random.choice([""1st"", ""2nd"", ""3rd"", ""4th"", ""5th"", ""6th"", ""7th"", ""8th"", ""9th"", ""10th""])
        yield date # yield makes a generator automatically which works in a similar way, this is much more efficient

dates_list = return_dates()
print(dates_list)
for i in dates_list:
    print(i)

dates_generator = yield_dates()
print(dates_generator)
for i in  dates_generator:
    print(i)
</code></pre>

<p>Both functions do the same thing but <code>yield</code> uses 3 lines instead of 5 and has one less variable to worry about.</p>

<p>This is the result from the code:</p>

<p><a href=""http://i.stack.imgur.com/iUFNJ.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/iUFNJ.png"" alt=""enter image description here""></a></p>

<p>As you can see both functions do the same thing, the only difference is <code>return_dates()</code> gives a list and <code>yield_dates()</code> gives a generator</p>

<p>A real life example would be something like reading a file line by line or if you just want to make a generator</p>
"
40022748,,231767.0,3104473.0,1,"<p>In summary, the <code>yield</code> statement transforms your function into a factory that produces a special object called a <code>generator</code> which wraps around the body of your original function. When the <code>generator</code> is iterated, it executes your function  until it reaches the next <code>yield</code> then suspends execution and evaluates to the value passed to <code>yield</code>. It repeats this process on each iteration until the path of execution exits the function. For instance;</p>

<pre><code>def simple_generator():
    yield 'one'
    yield 'two'
    yield 'three'

for i in simple_generator():
    print i
</code></pre>

<p>simply outputs ;</p>

<pre><code>one
two
three
</code></pre>

<p>The power comes from using the generator with a loop that calculates a sequence, the generator executes the loop stopping each time to 'yield' the next result of the calculation, in this way it calculates a list on the fly, the benefit being the memory saved for especially large calculations</p>

<p>Say you wanted to create a your own <code>range</code> function that produces an iterable range of numbers, you could do it like so,</p>

<pre><code>def myRangeNaive(i):
    n = 0
    range = []
    while n &lt; i:
        range.append(n)
        n = n + 1
    return range
</code></pre>

<p>and use it like this;</p>

<pre><code>for i in myRangeNaive(10):
    print i
</code></pre>

<p>but this is ineffecient because 1. You create an array that you only use once and 2. This code actually loops over that array twice! :( . Luckily Guido and his team were generous enough to develop generators so we could just do this;</p>

<pre><code>def myRangeSmart(i):
    n = 0
    while n &lt; i:
       yield n
       n = n + 1
    return

for i in myRangeSmart(10):
    print i
</code></pre>

<p>Now upon each iteration a function on the generator called <code>next()</code> executes the function until it either reaches a 'yield' statement in which it stops and  'yields' the value or reaches the end of the function. In this case on the first call, <code>next()</code> executes up to the yield statement and yield 'n', on the next call it will execute the  increment statement, jump back to the 'while', evaluate it, and if true, it will stop and yield 'n' again, it will continue that way until the while condition returns false and the generator jumps to the end of the function. </p>
"
2600191,How can I count the occurrences of a list item in Python?,,222893.0,592,"<p>Given an item, how can I count its occurrences in a list in Python?</p>
"
2600208,,2600191.0,4999.0,816,"<pre><code>&gt;&gt;&gt; [1, 2, 3, 4, 1, 4, 1].count(1)
3
</code></pre>
"
2600231,,2600191.0,54736.0,30,"<p><code>list.count(x)</code> returns the number of times <code>x</code> appears in a list</p>

<p>see:
<a href=""http://docs.python.org/tutorial/datastructures.html#more-on-lists"">http://docs.python.org/tutorial/datastructures.html#more-on-lists</a></p>
"
2600566,,2600191.0,114147.0,-1,"<p>I use <code>if x in []</code> to test for the existence of values, <code>count</code> is meant for another purpose, and for huge lists it's also faster than count. It returns <code>True</code> or <code>False</code>:</p>

<p>Edit: Sorry, I misunderstood your question, my bad.</p>

<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]
&gt;&gt;&gt; 3 in lst
True
&gt;&gt;&gt; 9 in lst
False
</code></pre>
"
5829377,,2600191.0,520287.0,913,"<p>If you are using Python 2.7 or 3 and you want number of occurrences for each element:</p>

<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']
&gt;&gt;&gt; Counter(z)
Counter({'blue': 3, 'red': 2, 'yellow': 1})
</code></pre>
"
7055873,,2600191.0,188833.0,9,"<pre class=""lang-py prettyprint-override""><code># Python &gt;= 2.6 (defaultdict) &amp;&amp; &lt; 2.7 (Counter, OrderedDict)
from collections import defaultdict
def count_unsorted_list_items(items):
    """"""
    :param items: iterable of hashable items to count
    :type items: iterable

    :returns: dict of counts like Py2.7 Counter
    :rtype: dict
    """"""
    counts = defaultdict(int)
    for item in items:
        counts[item] += 1
    return dict(counts)


# Python &gt;= 2.2 (generators)
def count_sorted_list_items(items):
    """"""
    :param items: sorted iterable of items to count
    :type items: sorted iterable

    :returns: generator of (item, count) tuples
    :rtype: generator
    """"""
    if not items:
        return
    elif len(items) == 1:
        yield (items[0], 1)
        return
    prev_item = items[0]
    count = 1
    for item in items[1:]:
        if prev_item == item:
            count += 1
        else:
            yield (prev_item, count)
            count = 1
            prev_item = item
    yield (item, count)
    return


import unittest
class TestListCounters(unittest.TestCase):
    def test_count_unsorted_list_items(self):
        D = (
            ([], []),
            ([2], [(2,1)]),
            ([2,2], [(2,2)]),
            ([2,2,2,2,3,3,5,5], [(2,4), (3,2), (5,2)]),
            )
        for inp, exp_outp in D:
            counts = count_unsorted_list_items(inp) 
            print inp, exp_outp, counts
            self.assertEqual(counts, dict( exp_outp ))

        inp, exp_outp = UNSORTED_WIN = ([2,2,4,2], [(2,3), (4,1)])
        self.assertEqual(dict( exp_outp ), count_unsorted_list_items(inp) )


    def test_count_sorted_list_items(self):
        D = (
            ([], []),
            ([2], [(2,1)]),
            ([2,2], [(2,2)]),
            ([2,2,2,2,3,3,5,5], [(2,4), (3,2), (5,2)]),
            )
        for inp, exp_outp in D:
            counts = list( count_sorted_list_items(inp) )
            print inp, exp_outp, counts
            self.assertEqual(counts, exp_outp)

        inp, exp_outp = UNSORTED_FAIL = ([2,2,4,2], [(2,3), (4,1)])
        self.assertEqual(exp_outp, list( count_sorted_list_items(inp) ))
        # ... [(2,2), (4,1), (2,1)]
</code></pre>
"
7057878,,2600191.0,551449.0,4,"<p>To count the number of diverse elements having a common type:</p>

<pre><code>li = ['A0','c5','A8','A2','A5','c2','A3','A9']

print sum(1 for el in li if el[0]=='A' and el[1] in '01234')
</code></pre>

<p>gives</p>

<p><code>3</code>  , not 6</p>
"
7843090,,2600191.0,1006167.0,46,"<p>Another way to get the number of occurrences of each item, in a dictionary:</p>

<pre><code>dict((i, a.count(i)) for i in a)
</code></pre>
"
8041395,,2600191.0,1034367.0,9,"<p>I had this problem today and rolled my own solution before I thought to check SO.  This:</p>

<pre><code>dict((i,a.count(i)) for i in a)
</code></pre>

<p>is really, really slow for large lists.  My solution</p>

<pre><code>def occurDict(items):
    d = {}
    for i in items:
        if i in d:
            d[i] = d[i]+1
        else:
            d[i] = 1
return d
</code></pre>

<p>is actually a bit faster than the Counter solution, at least for Python 2.7.</p>
"
20069518,,2600191.0,1954677.0,17,"<p>If you want to <strong>count all values at once</strong> you can do it very fast using numpy arrays and <code>bincount</code> as follows</p>

<pre><code>import numpy as np
a = np.array([1, 2, 3, 4, 1, 4, 1])
np.bincount(a)
</code></pre>

<p>which gives</p>

<pre><code>&gt;&gt;&gt; array([0, 3, 1, 1, 2])
</code></pre>
"
23909767,,2600191.0,2314737.0,84,"<p><strong>Counting the occurrences of one item in a list</strong></p>

<p>For counting the occurrences of just one list item you can use <code>count()</code></p>

<pre><code>&gt;&gt;&gt; l = [""a"",""b"",""b""]
&gt;&gt;&gt; l.count(""a"")
1
&gt;&gt;&gt; l.count(""b"")
2
</code></pre>

<p>Counting the occurrences of <em>all</em> items in a list is also known as ""tallying"" a list, or creating a tally counter.</p>

<p><strong>Counting all items with count()</strong></p>

<p>To count the occurrences of items in <code>l</code> one can simply use a list comprehension and the <code>count()</code> method</p>

<pre><code>[[x,l.count(x)] for x in set(l)]
</code></pre>

<p>(or similarly with a dictionary <code>dict((x,l.count(x)) for x in set(l))</code>)</p>

<p>Example: </p>

<pre><code>&gt;&gt;&gt; l = [""a"",""b"",""b""]
&gt;&gt;&gt; [[x,l.count(x)] for x in set(l)]
[['a', 1], ['b', 2]]
&gt;&gt;&gt; dict((x,l.count(x)) for x in set(l))
{'a': 1, 'b': 2}
</code></pre>

<p><strong>Counting all items with Counter()</strong></p>

<p>Alternatively, there's the faster <code>Counter</code> class from the <code>collections</code> library</p>

<pre><code>Counter(l)
</code></pre>

<p>Example:</p>

<pre><code>&gt;&gt;&gt; l = [""a"",""b"",""b""]
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; Counter(l)
Counter({'b': 2, 'a': 1})
</code></pre>

<p><strong>How much faster is Counter?</strong></p>

<p>I checked how much faster <code>Counter</code> is for tallying lists. I tried both methods out with a few values of <code>n</code> and it appears that <code>Counter</code> is faster by a constant factor of approximately 2.</p>

<p>Here is the script I used:</p>

<pre><code>import timeit

t1=timeit.Timer('Counter(l)', \
                'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'
                )

t2=timeit.Timer('[[x,l.count(x)] for x in set(l)]',
                'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'
                )

print ""Counter(): "", t1.repeat(repeat=3,number=10000)
print ""count():   "", t2.repeat(repeat=3,number=10000)
</code></pre>

<p>And the output:</p>

<pre><code>Counter():  [6.360648187146579, 6.613881559699756, 6.392260466851987]
count():    [12.885062765334006, 13.045601897769359, 12.87746743077426]
</code></pre>
"
36598953,,2600191.0,541136.0,5,"<blockquote>
  <h1>Given an item, how can I count its occurrences in a list in Python?</h1>
</blockquote>

<pre><code>&gt;&gt;&gt; l = list('aaaaabbbbcccdde')
&gt;&gt;&gt; l
['a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'e']
</code></pre>

<h1><code>list.count</code></h1>

<p>There's the <code>list.count</code> method</p>

<pre><code>&gt;&gt;&gt; l.count('b')
4
</code></pre>

<h1><code>collections.Counter</code></h1>

<p>And then there's collections.Counter. Usage:</p>

<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter(l)
&gt;&gt;&gt; c['b']
4
</code></pre>

<h2>Further usage of <code>collections.Counter</code></h2>

<p>You can add or subtract with iterables from your counter:</p>

<pre><code>&gt;&gt;&gt; c.update(list('bbb'))
&gt;&gt;&gt; c['b']
7
&gt;&gt;&gt; c.subtract(list('bbb'))
&gt;&gt;&gt; c['b']
4
</code></pre>

<p>And you can do multi-set operations with the counter as well:</p>

<pre><code>&gt;&gt;&gt; c2 = Counter(list('aabbxyz'))
&gt;&gt;&gt; c - c2                   # set difference
Counter({'a': 3, 'c': 3, 'b': 2, 'd': 2, 'e': 1})
&gt;&gt;&gt; c + c2                   # addition of all elements
Counter({'a': 7, 'b': 6, 'c': 3, 'd': 2, 'e': 1, 'y': 1, 'x': 1, 'z': 1})
&gt;&gt;&gt; c | c2                   # set union
Counter({'a': 5, 'b': 4, 'c': 3, 'd': 2, 'e': 1, 'y': 1, 'x': 1, 'z': 1})
&gt;&gt;&gt; c &amp; c2                   # set intersection
Counter({'a': 2, 'b': 2})
</code></pre>
"
39562168,,2600191.0,3124746.0,1,"<p>You can also use <a href=""https://docs.python.org/3/library/operator.html#operator.countOf"" rel=""nofollow""><code>countOf</code></a> method of a built-in module <a href=""https://docs.python.org/3/library/operator.html"" rel=""nofollow""><code>operator</code></a>.</p>

<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; operator.countOf([1, 2, 3, 4, 1, 4, 1], 1)
3
</code></pre>
"
40092132,,2600191.0,5553237.0,0,"<p>Why not using Pandas?</p>

<pre><code>import pandas as pd
l = ['a', 'b', 'c', 'd', 'a', 'd', 'a']
# converting the list to a Series and counting the values
my_count = pd.Series(l).value_counts()
</code></pre>

<p>Output:</p>

<pre><code>a    3
d    2
b    1
c    1
dtype: int64
</code></pre>

<p>If you are looking for a count of a particular element, say <em>a</em>, try:</p>

<pre><code>my_count['a']
</code></pre>

<p>Output:</p>

<pre><code>3
</code></pre>
"
